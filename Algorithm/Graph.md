# Graph 

## 1. Graph란?
    Graph는 연결되어있는 원소간의 관계를 표현하는 자료구조이다.
그래프는 선형자료구조나 트리가 표현할 수 없는 모든 연결 구조들을 표현할 수 있기 때문에 여러분야에서 폭 넓게 사용할 수 있다.  
그래프는 연결할 객체를 나타내는 정점(vertax)과 객체를 연결하는 간선(edge)의 집합으로 구성된다. 그래프 G를  G=(V,E)로 정의하는데 V는 그래프에 있는 정점들의 집합을 의미하고, E는 정점을 연결하는 간선들의 집합을 의미한다.

## 2. Graph 종류
방향그래프는 cyclic(하나 이상의 사이클 있는 그래프) <-> Acyclic  

    그래프는 방향성과 연결 정도에 따라 여러 형태가 있다.
- Undirected Graph : 두정점을 연결하는 간선에 방향이 없는 Graph로 무방향그래프라고 한다.
- Directed Graph :
- Complete Graph :
- subgraph :
- weight graph :
## 3. Graph 구현
Graph를 표현하는 방법에는 2가지가 있음  
- Adjacency Matrix : 2차원 배열에 나열하는 방법  
그래프를 표(2차원 배열)에 표현하는 방법. 즉, 연결되면 1로 표현하고, 아니면 0으로 표현한다.
- Adjacency List : 배열과 Linked List로 나열하는 방법  
배열방에 각각 Linked List가 존재하고, 해당 노드에 인접한 노드는 Linked List에 순서 상관없이 나열함 => 노드의 갯수가 n개이면, list의 총 노드는 2n개가 발생함   
### 3.1 순차 자료구조 방식을 이용한 그래프의 구현
### 3.2 연결 자료구조 방식을 이용한 그래프의 구현

## 4. Graph 순회
- Depth - First - Search(DFS : 깊이 우선 방법) :  
  tree 검색 방법이었던 inorder,preorder,postorder들도 DFS에 속한다.  즉, child노드 이어가면서 leaf까지 가고 다시 올라가서 다시 아래로 내려가는 같은 방법으로 가능 방법이다.   
  Stack을 이용해 구현 : 시작 노드를 stack에 넣고, 시작노드를 출력할때, 자식노드들을 stack에 입력하고, 그중에 노드 한개를 출력할때 해당 노드의 자식 노드들을 입력함을 반복한다. stack이기 때문에 깊이 우선 방식이ㅏㄷ..응? 단, 한번 입력했던 노드는 다시 넣지 않는다.  
  재귀호출(Recursion)을 이용해 구현 : 시작노드를 호출하면, 자식노드를 호출하고 재귀호출이 계속 반복한다. 이때, 자식노드들을 호출할때, 정방향으로 우선적으로 호출한다. 또한, 자식노드들(a,b_) 중 정방향의 노드(a)를 우선 호출하여 해당 자식 노드들(b,c)을 호출하는데 여기에 형제 노드이면서 자식 노드인 (b)가 먼저 호출 되는것 이 아닌 어느 쪽부터 먼저 입력했는가를 우선적으로 호출???? 한다. 
- Breadth - First - Search(BFS : 넓이 우선 방법) : level단위로 형제노드들을 검색하는 방법  
  Queue를 이용해 구현 : 시작노드를 queue에 입력하고, 출력할때, 자식노드들을 queue에 입력하고, 반복한다. 여기서 후입선출이 아닌 선입선출이라는 점이 다르다. 이 점이, 넓이 우선 방식이다.엥????? DFS와 마찬가지로 한 번 넣었던 노드는 다시 입력하지 않는다. 
## 5. 신장트리와 최소 비용 신장 트리
사실 tree는 graph의 한종류이다.? tree는 graph에서 루트가 있고, 사이클이 없으며, 아래로만 흐르는 한방향이며, 들어오는 곳이 한개이다.? 그래프는 tree와는 달리 제약이 없다.  
그래프는 방향이 있을수도 없을수도 있다. tree는  Directed graph이다. 방향 그래프는 셀프엣지라고 자기자신을 가리키루도 있다.  

그래프에는 tree와는 달리 부모 자식 관계가 없다.

### 6.1 신장트리

### 6.2 최소 비용 신장트리

---

## Reference

- 자바로 배우는 자료구조 방식