자료구조
===

1.1 자료구조란?
===

    데이터 표현 및 저장방식
    다양한 자료를 효율적으로 표현해 저장하고 처리하여 사용할 수 있도록 하는것  


1.2 왜 자료구조를 사용하는가?
===
    컴퓨터의 동작성능은 명령을 내려주는 사람에 따라 달라지기 때문이다.

    표현하고자 하는 자료의 특성과 양, 자료의 주된 사용 방법과 수행하는 연산의 종류, 구현에 필요한 기억공간 용량을 고려하여 가장 효율적인 자료구조를 선택하면, 컴퓨터의 동작 성능은 월등히 올라가게 된다. 그렇기 때문에 우리는 자료구조를 공부해야하고 알고리즘을 공부해야한다.

    문제 해결을 위해 추상적으로 정의한 데이터와 연산자를 구체적으로 구현하여 실행해야 하는데, 연산자의 구현은 데이터를 표현하는 방법에 의해 결정된다. 따라서 처리할 문제에 대한 데이터를 가장 효율적인 방법으로 표현하는것이 중요하므로, 자료구조에 대해 공부해야하낟.

1.3.자료구조 형태에 따른 분류
===
- **단순 구조** : 정수, 실수, 문자, 문자열 등의 데이터 타입
- **선형 구조** : 자료 간에 일대일의 관계를 가지고 구조
- **비선형 구조** : 자료 간에 1:n or n:n 관계를 가지는 구조
- **파일 구조**

2.LIST : 자료구조의 데이터를 구조화 시키는 기본표현방식
===
    데이터를 구조화시키는 가장 기본적인 방법은 자료를 순서대로 나열하여 리스트를 구성하는
2.1 순차 자료구조 방식
---
리스트에서 나열한 원소들간에 순서를 가지고 있는 리스트를 선형리스트 또는 순서 리스트라 한다. 이러한 리스트는 원소들간에 논리적인 순서와 메모리에 저장하는 물리적인 순서가 같은 구조로 되어있는데, 이러한 구조를 **순차 자료구조**라고 한다.   
   
[ 장점 ]
- 순차 자료구조에서는 원소의 논리적인 순서대로 데이터가 메모리에 저장되기 때문에, 시작위치와 원소의 길이를 알면 특정 원소의 위치를 알 수 있다.
- 그렇기대문에 원소들의 순서를 따로 표시할 필요가 없이 간단히 구성할 수가 있고, 인덱스를 사용하여 특정 원소를 쉽게 엑세스할 수 있다.

[ 단점 ]
- 물리적인 순서대로 연속하여 저장되기 때문에, 원소 삽입혹은 삭제가 발생할 경우 발생한 원소 이후에 있는 원소들은 한자리씩 뒤로 이동하거나 앞으로 이동해야한다.(원소들의 이동작업 필요)  
    => 순차자료구조는 논리적인순서와 물리적인순서가 같은순서대로 연속적으로 저장되기때문에 중간에 빈자리가 있어서는 안되기 때문
- 원소를 삽입하거나 삭제할 경우에 물리적으로 원소들을 뒤로 밀어내거나 앞으로 당겨서 순서를 유지해야     하기 때문에 원소이동작업으로 추가적인 오버헤드가 많이 발생하여 성능상의 문제를 일으킬 수 있다.    
- 순차 자료구조 방식은 배열을 이용하여 구현하기 때문 배열이 갖고 있는 메모리 사용의 비효율성 문제를 그대로 갖는다.
##

    순차 자료구조는 삽입/삭제 연산이 많이 필요한 문제에서 순차 자료구존를 사용하는 것은 비효율적이다.


2.1 연결 자료구조 방식 (=비순차 자료구조 방식)
---
순차 자료구조방식에서의 연산시간에 대한 문제와 저장공간에 대한 문제를 개선한 자료구조 표현방식
- 연결리스트는 리스트를 연결 자료구조방식으로 표현한 리스트로서 연결하는 방식에 따라 단순 연결 리스트와 원형 연결 리스트, 이중 연결 리스트, 이중 원형 연결 리스트가 있다.
- 연결자료 방식은 순차와 달리 논리적인 순서와 물리적인 순서가 일치할 필요가 없다.
- 연속한 메모리 물리주소에 의해 원소의 순서를 표현하는 것이 아니라, 각 원소에 저장되어 있는 다음 원소의 주소에 대한 참조에 의해서 연결되는 방식이기대문에, 물리적인 순서를 맞추기 위한 오버헤드가 발생하지 않는다.
- 하나의 순차 자료구조를 위해서는 하나의 고정크기 메모리 공간을 사용하지만, 연결 자료구조에서는 여러개의 작은공간을 연결하여 전체를 표현하기 때문에 크기변경이 유연하고 좀더 효율적으로 메모리를 사용할 수 있다. => 중요한거 같음 더 공부 필요
##
    [ 노드 ]
    연결 자료구조 방식에서 원소는 연결될 다음 원소에 대한 주소를 저장해야 하기 때문에 <원소,주소>의 단위로 저장해야 한다. 이러한 단위구조를 노드(node)라고 한다.  
      
    노드는 [data][link]에서와 같이 원소의 값을 저장하는 데이터 필드와 다음 노드의 주소를 저장하는 링크 필드로 구성된다.   
    데이터필드 : 저장할 원소의 형태에 따라서 하나 이상의 필드로 구성하기도 한다.
    링크필드 : 메모리 참조 변수를 사용하여 주소에 대한 참조값을 저장하며, 링크 또는 참조라고 한다.  
    => 죽, 데이터 필드 : 링크 필드 = N : 1 의 관계를 가진다. (뒤로 가면 N : 2의 관계도 가짐을 알 수 있다.)  

    참조값(링크값)(리스트 이름) [첫번째 노드의 주소 참조값] => 리스트 이름은 첫번째 노드에 대한 참조를 나타내지만, 첫번째 노드에 연결된 리스트 전체를 의미??  
    리스트 이름은 연결리스트의 시작 위치를 가리키는 메모리 참조변수이기도 하다
    첫번째 참조값[첫번째 데이터 필드 : 두번쩨 노드의 주소] =>다음에 연결할 노드의 주소에 대한 참조값을 저장하고 잇음
    두번째 참조값[마디막 데이터 필드 : null] => 더이상 연결할 노드가 없기 때문에 링크필드에 null을 저장한다.  
    만약  노드가 하나도 없는 공백 연결 리스트일 경우 참조변수(리스트 이름)에  null을 저장한다.  

    각 노드 필드에 저장한 값은 참조변수의 점 연산자를 사용하여 엑세스한다.   
    week.data는 참조변수 week가 가리키는 첫번째 노드필드의 데이터필드값이 된다.
    week.link는 참조변수 week가 가리키는 첫번째 노드필드의 링크필드값이 된다.
    week.link.data는 참조변수 week가 가리키는 노드필드의 링크필드가 가리키는 데이터 필드값이 된다. 즉, 두번째 노드의 데이터 필드값이 된다.
##

    장점
    - 연결 구조는 링크필드에 대한 저장공간이 추가로 필요하지만, 순차구조에서 물리적 순서를 맞추기 위해 필요한 오버헤드가 없기때문에 연결 구조를 더 많이 사용한다.'
    - 링크필드의 참조값에 대한 연산만으로 쉽게 삽입/삭제연산을 수행할 수 있다.
    - 순차 선형리스트와는 달리 원소이동현상이 일어나지 않는다.

  
### 1) 단순 연결 리스트(=연결리스트=선형연결리스트=단순연결선형리스트)
: 노드가 하나의 링크 필드에 의해서 다음 노드와 연결되는 구조를 가진 연결 리스트다.

#### (1) 단순 연결 리스트의 노드 삽입 / 삭제 연산
- 삽입연산일 경우, 앞의 노드는 삽입할 노드의 참조값을 저장하고 삽입할 노드는 다음 노드의 참조값을 저장한다.
- 삭제연산일 경우, 앞의 노드에 삭제할 노드의 참조값으로 덮어씌운다. 이때 삭제할 노드는 여전히 다음노드의 참조값을 저장하고 있지만, 삭제할 노드를 연결하는 앞의 노드가 삭제할노드를 가르키지 않기때문에 굳이 삭제할 노드에  null을 저장할 수고를 줄일 수 있다. 이미 의미없는 값이 되었기 때문이다.
- 순차 선형리스트와 달리 단순 연결 리스트의 삽입 연산에서는 물리적 순서를 유지하기 위해서 원소이동현상이 일어나지 않는다.   
#### (2) 단점
시작노드에서 링크를 따라 이동하여 마지막 노드까지 한방향으로만 순회할 수 있는 구조이다. 그렇기 때문에, 현재 노드에서 이전 노드를 접슨(엑세스)하려면 현재 위치에 상관없이 항상 리스트의 첫 번째 노드부터 다시 시작해야한다.

### 2) 원형 연결 리스트
: 단순 연결 리스트에서 마지막 노드가 리스트의 첫번째 노드를 가리키게 하여 리스트의 구조를 원형으로 만든 연결리스트를 원형 연결 리스트라 한다.  

단순연결리스트와는 달리 이전 노드를 접근하기 위해 첫번째 노드부터 다시 시작할 필요가 없다. 원형으로 계속 순회하기 때문에 링크를 따라 계속 순회하면 이전 노드에 접근할 수 있다.
#### (1) 원형 연결 리스트의 삽입 / 삭제 연산
- 삽입 연산 : 마지막 노드의 링크를 NULL로 두는 것이 아니라 첫번째 노드로 연결하는 부분만 제외하고는 단순 연결 리스트에서의 연산과 같다.
- 삭제 연산: 마지막 노드 혹은 첫번째 노드 삭제시 다시 다음 마지막 노드 혹은 첫번째 노드와 연결해야하는 부분만 제외하고는 단순 연결 리스트에서의 연산과 같다.

#### (2) 단점
단순 연결 리스트에서 선행 노드에 접근하기가 어렵다는 점을 개선하여, 원형 연결 리스트를 구성했지만, 원형 연결 리스트에서도 현재 노드의 바로 이전 노드에 접근하려면 전체 리스트를 한바퀴 순회해야하는 문제가 있다. 이러한 문제는 리스트의 링크가 한 방향으로만 되어있어서 반대 방향으로는 순회할 수 없기 때문에 발생한다. 

### 3) 이중 연결 리스트 / 이중 원형 연결 리스트
: 위의 단점을 보완하기위해 양방향으로 순회할 수 있도록 연결한 리스트를 이중 연결 리스트라고 한다. 
- 이중연결리스트의 노드구보 : [ 링크필드(llink/left filed) ][ 데이터필드 ][ 링크핑드(rlink/right filed  ) ] 두 개의 링크 필드와 한개의 데이터 필드로 구성된다.  
=> 오른쪽 링크필드가 오른쪽 노드의 참조값을 저장하고 있고, 왼쪽 링크 필드가 왼쪽 노드이 참조값을 저장하고 있다. 그리고 각각의 링크필드는 양쪽으로 원형으로 순회하고 있기 때문에, 원형 이중 연결 리스트가 된다. 이때 원형으로 순회하고 있지않지만, 양 방향으로 진행된다면, 이중 연결 리스트라고 한다.?

#### (1) 이중 원형 연결 리스트의 삽입 / 삭제 연산
: 삽입/삭제 연산 모두 원형 연결리스트와 같은 방법으로 진행되지만, 양쪽방향으로 모두 진행된다는것이 다른 점이다. 

### +) 자유공간리스트
연결 리스트에서 삽입연산을 하려면 먼저 메모리에서 공백노드를 가져와야하고, 삭제연산에서는 삭제되어 사용하지않는 노드에 대한 메모리공간을 처리해야 한다. 즉, 삽입/삭제 연산시에 메모리할당작업이 필요하다.  
이러한 작업을 사용하지 않은 메모리 공간이 미리 노드의 구조로 나누어져 연결리스트로 만들어져 노드를 할당하거나 혹은 반환받을 수 있다면, 연산과정과 메모리 관리가 효율적으로 이루어질 수 있다.  
이렇게 메모리를 사용하기 전에 미리 노드를 나누어서 연결해 놓은 리스트를 자유공간리스트(Free Space List)라고 한다.  

3.1 Stack
===
: 자료를 순서대로 나열하여 리스트를 구성하는 것 이외에 자료를 나열하는 방법을 제한하는 몇 가지 규칙을 추가하여 리스트를 응용한 자료구조를 만들 수 있다.  

스택 이란 쌓아 올린다는 의미다. 따라서 스택 자료구조라는 것은 접시를 쌓듯이 자료를 차곡차곡 쌓아 올린 쳥태의 구조를 말한다. 즉, 스택은 같은 구조와 크기의 자료를 top이라고 정한 한 곳으로만 쌓을 수 있고, top으로만 접근하도록 제한하여 만든 자료구조다.  

스택에서는 새ㅔ을 통해서 들어온 자료가 일정한 방향으로 쌓인다. 나중에 들어온 자료가 맨 위에 위치하게 되고, 삭제하는 자료도 가장 위에 위치하는 자료이다. 따라서, 스택은 시간 순서에 따라 자료가 쌓이고, 삭제할때는 가장 마지막에 삽입된 자료가 가장먼 먼저 삭제되는 후입선출(LIFO, Last-In-First-Out)의 구조를 가진다.  

스택에서 top을 통한 삽입 연산을 push, top을 통한 삭제연산을 pop라고 한다.   

1) 순차 자료구조방식을 이용한 스택의 구현
--- 
순차 자료구조인 1차원 배열을 이용하여 스택을 구현할 수 있다. 1차원 배열 stack[n]을 사용할 때, n은 배열 크기로서 배열 원소의 갯수를 나타내는데, 이것이 스택의 크기가 된다. 스택에 원소가 쌓이는 순서는 배열의 인덱스(index)로 표현한다. 따라서 스택의 첫번째 원소는 stack[0]에 저장하고, i번째 원소는 stack[i-1]에 저장한다.  

스택의 top을 표현하기 위해서 배열 stack의 마지막 원소의 인덱스 값을 변수 top에 저장한다. 변수 top은 0부터 n-1까지의 인덱스(1~n-1)를 저장하므로, 스택이 초기 상태(공백)일 때 top은 -1을 저장한다. 변수 top값은 삽입 혹은 삭제 연산을 하면서 값이 지속적으로 바뀐다.

2) 연결 자료구조 방식을 이용한 스택의 구현
---
순차 자료구조를 이용한 스택은 배열을 사용하여 구현하기는 쉽지만, 물리적으로 크기가 고정된 배열을 사용하기 때문에 스택의 크기를 변경하기가 어렵고, 메모리의 낭비가 생길 수 있다는 문제가 있다. 이러한 순차 자료구조 방식의 문제는 연결 자료구조 방식을 이용함으로써 해결할 수 있다.  

연결 자료구조 방식의 단순 연결 리스트를 이용하여 스택을 구현하면, 스택의 원소는 연결리스트의 노드가 된다. 스택에 원소를 삽입할 때마다 연결 리스트에 노드를 하나씩 연결한다. 그리고 스택원소들간의 순서는 연결리스트 노드의 링크를 사용하여 표현한다. 스택의 top을 표현하기 위해서 참조 변수 top(리스트 이름?)을 사용한다.  스택이 초기 상태일 경우 top은 null이지만, 삽입할때마다 참조변수의 값이 새로 저장한 노드의 참조값으로 저장하게 된다. 즉, 연결 자료구조 방식은 첫번째 노드에 계쏙 삽입이 되어서 참조변수의 값이 계속 바뀌는 구조이다.

PUSH 일 경우 순차와 마찬가지로 TOP에 마지막원소의 참조값이 저장된다. 즉, PUSH를 할 경우 뒤에 연결되는 것이 아니라 앞에 연결이 된다. POP 삭제 또한 앞에서부터 삭제가 되고, OP 참조값이 변경이 된다. 이렇나 과정은 후입선출 구조 임을 알 수 있다.후입(앞에서 PUSH)선출(앞에서 POP), 즉 이때의 TOP은 순차와는 달리 첫번째 위치임을 의미함을 알 수 있다.?

3.2 Queue
===

1) Queue의 구조
---

큐는 스택과 마찬가지로 삽입과 삭제의 위치와 방법이 제한되어 있는 유한 순서 리스트(Fiinite Ordered List)지만, 스택과 달리 리스트의 한쪽 끝에서는 삽입 작업이 이루어지고, 반대쪽에서는 삭제작업이 이루어져서, 삽입된 순서대로 삭제되는 선입선출(FIFO)의 구조를 가진다. 큐는 한쪽 끝을 나가는 위치(프런트/front)로 정하여 삭제연산만 수행하도록 하였고, 다른 쪽 끝은 들어오는 위치(리어/rear)로 정하여 삽입 연산만 수행하도록 제한한다. 큐에서 프런트 원소는 가장 먼저 큐에 들어온 첫 번째 원소이고, 리어 원소는 큐에 가장 늦게 들어온 마지막 원소이다. 따라서 가장 먼저 들어온 프런트 원소가 가장 먼저 삭제되고, 가장 마지막에 들어온 원소가 리어원소가 되는 선입선출 구조가 된다.

큐의 리어에서 이루어지는 삽입 연산을 인큐(enQueue)라고 하고, 프런트에서 이루어지는 삭제연산을(deQueue)라고 한다. Stack과는 달리 삽입과 삭제연산이 이루어지는 곳이 일치함을 알 수 있다. 

2) 순차 자료구조 방식을 이용한 큐의 구현
---

- 선형큐  
1차원 배열을 사용하여 큐를 구현하게 되면, 배열의 크기는 큐의 크기, 즉 큐에 저장할 수 있는 최대 원소의 개수가 된다. 그리고 첫번째 원소의 인덱스를 저장할 front변수와 저장된 마지막 원소의 인덱스를 저장할 rear변수를 사용한다. 초기 공백 큐의 상태는 front와 rear가 같은 위치에 있는 상태이기 대문에 front변수와 rear변수의 값을 -1로 설정한다. 큐가 포화 상태인 경우는 배열의 마지막 인덱스까지 원소가 저장된 경우이므로 즉, rear의 값이 배열의 마지막 인덱스(n-1)이어야 한다. 포화 상태의 조건은 rear의 값이 n-1 즉, 마지막 인덱스이고, 공백 상태의 조건은 rear = front = -1 ? 인 경우이다.

- 원형 큐  
선형큐 즉, 1차원 배열을 사용한 순차 자료구조 방식에서는 큐가 포화상태가 아닐 경우에만 삽입연산을 수행하도록 정의되어 있다. 그러나, front의 위치가 진짜 이 아닐경우, 빈자리가 있음에도 raer가 n-1이므로 포화상태로 인식한다. 삽입/삭제 연산을 진행하지 않는다. 그렇기에 빈부분을 없애기 위해 앞부분으로 이동시켜 위치를 조정해야한다. 이러한 이동 작업은 큐의 효율성을 떨어 뜨린다.  
이러한 문제를 해결하기 위해 , 원형큐를 사용한다. 원형큐는 1차원배열을 사용하지만 처음과 끝이 연결되어 있다는 차이점이 있다.  
원형큐에서는 초기 공백 상태일 때 front와 rear의 값이 0이 되고, 공백 상태와 포화 상태를 구분하기 위해서 자리 하는 항상 비워둔다. 원형큐에서는 공백 상태 조건은 front = rear가 된다.  rear는 앞으로 이동하면서 원소를 삽입하고, front는 rear가 이동한 방향을 따라가면서 원소를 삭제한다. 원형 큐에서는 배열의 인덱스가 n-1다음에 다시 0이 되어야하므로 사용할 다음 인덱스를 정하기 위해서 나머지 연산자 mod를 사용한다.? 즉, 포화상태인 rear의 다음 위치 ((rear+1) mod n)는 현재의 front위치가 되어 더 이상 원소를 삽입할 수 없는 포화 상태가 된다..?????

3) 연결 자료구조 방식을 이용한 큐의 구현

- 연결큐  
순차자료구조방식을 이용하게되면, 사용 크기가 데한되어 있어서 큐의 길이를 마음대로 변경할 수 없고, 원소가 없을 때에도 항상 처음 크기를 유지하고 있어야 하므로 메모리도 낭비된다. 이러한 문제를 극복하기 위해 연결 자료구조 방식을 이요하여 크기에 제한이 없는 연결큐를 구현한다.  
연결 큐에서 원소는 데이터 필드와 링크 필드를 가진 노드로 구성하며, 첫 번째 노드를 가리키는 참조변수 front와 마지막 노드를 가리키는 참조변수 rear를 사용한다.(참조변수가 2개를 가진다.) 연결큐의 초기 상태는 front와 rear를 NULL로 초기화하여 표현한다. 즉, 둘다 NULL이면 공백 상태임을 알 수 있다. 삽입연산 시 새노드를 생성하여 데이터 필드에 저장하고, 삽입할 새 노드는 마지막 노드가 되어야하므로 링크 필드에 NULL로 저장한다. 이때 공백 상태였을 경우 FRONT, REAR모두 마지막 노드를 가리키고 참조값을 저장한다. 공백상태가 아니었던 경우에는 마지막이었던 노드가 삽입한 노드 의 참조값을 저장하고(마지막 노드 뒤에 새노드를 삽입) REAR 또한 해당 노드를 가리키도록 설정한다.  삭제연산의 경우에는 첫번째 노드를 삭제하고, FRONT가 새로운 첫번째 노드를 가리킨다. 이때 만약에 노드가 남지 않는다면 FRONT와 REAR에 참조된 값을 지우고 NULL로 초기화시켜준다.

- 덱  
덱(Deque)은 큐의 양쪽 끝에서 삽입과 삭제가 모두 발생하는 큐로서, 스택과 큐의 성지릉ㄹ 모두 가지고 있다.  
덱 연산은 스택과 큐의 연산을 모두 가지고 있다. front/rear를 스택의 top으로 생각하여 push,pop연산 모두 각각 가능하다.