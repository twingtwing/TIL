자료구조
===

1.1 자료구조란?
===

    데이터 표현 및 저장방식
    다양한 자료를 효율적으로 표현해 저장하고 처리하여 사용할 수 있도록 하는것  


1.2 왜 자료구조를 사용하는가?
===
    컴퓨터의 동작성능은 명령을 내려주는 사람에 따라 달라지기 때문이다.

    표현하고자 하는 자료의 특성과 양, 자료의 주된 사용 방법과 수행하는 연산의 종류, 구현에 필요한 기억공간 용량을 고려하여 가장 효율적인 자료구조를 선택하면, 컴퓨터의 동작 성능은 월등히 올라가게 된다. 그렇기 때문에 우리는 자료구조를 공부해야하고 알고리즘을 공부해야한다.

    문제 해결을 위해 추상적으로 정의한 데이터와 연산자를 구체적으로 구현하여 실행해야 하는데, 연산자의 구현은 데이터를 표현하는 방법에 의해 결정된다. 따라서 처리할 문제에 대한 데이터를 가장 효율적인 방법으로 표현하는것이 중요하므로, 자료구조에 대해 공부해야하낟.

1.3.자료구조 형태에 따른 분류
===
- **단순 구조** : 정수, 실수, 문자, 문자열 등의 데이터 타입
- **선형 구조** : 자료 간에 일대일의 관계를 가지고 구조
- **비선형 구조** : 자료 간에 1:n or n:n 관계를 가지는 구조
- **파일 구조**

2.LIST : 자료구조의 데이터를 구조화 시키는 기본표현방식
===
    데이터를 구조화시키는 가장 기본적인 방법은 자료를 순서대로 나열하여 리스트를 구성하는
2.1 순차 자료구조 방식
---
리스트에서 나열한 원소들간에 순서를 가지고 있는 리스트를 선형리스트 또는 순서 리스트라 한다. 이러한 리스트는 원소들간에 논리적인 순서와 메모리에 저장하는 물리적인 순서가 같은 구조로 되어있는데, 이러한 구조를 **순차 자료구조**라고 한다.   
   
[ 장점 ]
- 순차 자료구조에서는 원소의 논리적인 순서대로 데이터가 메모리에 저장되기 때문에, 시작위치와 원소의 길이를 알면 특정 원소의 위치를 알 수 있다.
- 그렇기대문에 원소들의 순서를 따로 표시할 필요가 없이 간단히 구성할 수가 있고, 인덱스를 사용하여 특정 원소를 쉽게 엑세스할 수 있다.

[ 단점 ]
- 물리적인 순서대로 연속하여 저장되기 때문에, 원소 삽입혹은 삭제가 발생할 경우 발생한 원소 이후에 있는 원소들은 한자리씩 뒤로 이동하거나 앞으로 이동해야한다.(원소들의 이동작업 필요)  
    => 순차자료구조는 논리적인순서와 물리적인순서가 같은순서대로 연속적으로 저장되기때문에 중간에 빈자리가 있어서는 안되기 때문
- 원소를 삽입하거나 삭제할 경우에 물리적으로 원소들을 뒤로 밀어내거나 앞으로 당겨서 순서를 유지해야     하기 때문에 원소이동작업으로 추가적인 오버헤드가 많이 발생하여 성능상의 문제를 일으킬 수 있다.    
- 순차 자료구조 방식은 배열을 이용하여 구현하기 때문 배열이 갖고 있는 메모리 사용의 비효율성 문제를 그대로 갖는다.
##

    순차 자료구조는 삽입/삭제 연산이 많이 필요한 문제에서 순차 자료구존를 사용하는 것은 비효율적이다.

2.2 연결 자료구조 방식 (=비순차 자료구조 방식)
---
순차 자료구조방식에서의 연산시간에 대한 문제와 저장공간에 대한 문제를 개선한 자료구조 표현방식
- 연결리스트는 리스트를 연결 자료구조방식으로 표현한 리스트로서 연결하는 방식에 따라 단순 연결 리스트와 원형 연결 리스트, 이중 연결 리스트, 이중 원형 연결 리스트가 있다.
- 연결자료 방식은 순차와 달리 논리적인 순서와 물리적인 순서가 일치할 필요가 없다.
- 연속한 메모리 물리주소에 의해 원소의 순서를 표현하는 것이 아니라, 각 원소에 저장되어 있는 다음 원소의 주소에 대한 참조에 의해서 연결되는 방식이기대문에, 물리적인 순서를 맞추기 위한 오버헤드가 발생하지 않는다.
- 하나의 순차 자료구조를 위해서는 하나의 고정크기 메모리 공간을 사용하지만, 연결 자료구조에서는 여러개의 작은공간을 연결하여 전체를 표현하기 때문에 크기변경이 유연하고 좀더 효율적으로 메모리를 사용할 수 있다. => 중요한거 같음 더 공부 필요
##
    [ 노드 ]
    연결 자료구조 방식에서 원소는 연결될 다음 원소에 대한 주소를 저장해야 하기 때문에 <원소,주소>의 단위로 저장해야 한다. 이러한 단위구조를 노드(node)라고 한다.  
      
    노드는 [data][link]에서와 같이 원소의 값을 저장하는 데이터 필드와 다음 노드의 주소를 저장하는 링크 필드로 구성된다.   
    데이터필드 : 저장할 원소의 형태에 따라서 하나 이상의 필드로 구성하기도 한다.
    링크필드 : 메모리 참조 변수를 사용하여 주소에 대한 참조값을 저장하며, 링크 또는 참조라고 한다.  
    => 죽, 데이터 필드 : 링크 필드 = N : 1 의 관계를 가진다. (뒤로 가면 N : 2의 관계도 가짐을 알 수 있다.)  

    참조값(링크값)(리스트 이름) [첫번째 노드의 주소 참조값] => 리스트 이름은 첫번째 노드에 대한 참조를 나타내지만, 첫번째 노드에 연결된 리스트 전체를 의미??  
    리스트 이름은 연결리스트의 시작 위치를 가리키는 메모리 참조변수이기도 하다
    첫번째 참조값[첫번째 데이터 필드 : 두번쩨 노드의 주소] =>다음에 연결할 노드의 주소에 대한 참조값을 저장하고 잇음
    두번째 참조값[마디막 데이터 필드 : null] => 더이상 연결할 노드가 없기 때문에 링크필드에 null을 저장한다.  
    만약  노드가 하나도 없는 공백 연결 리스트일 경우 참조변수(리스트 이름)에  null을 저장한다.  

    각 노드 필드에 저장한 값은 참조변수의 점 연산자를 사용하여 엑세스한다.   
    week.data는 참조변수 week가 가리키는 첫번째 노드필드의 데이터필드값이 된다.
    week.link는 참조변수 week가 가리키는 첫번째 노드필드의 링크필드값이 된다.
    week.link.data는 참조변수 week가 가리키는 노드필드의 링크필드가 가리키는 데이터 필드값이 된다. 즉, 두번째 노드의 데이터 필드값이 된다.
##

    장점
    - 연결 구조는 링크필드에 대한 저장공간이 추가로 필요하지만, 순차구조에서 물리적 순서를 맞추기 위해 필요한 오버헤드가 없기때문에 연결 구조를 더 많이 사용한다.'
    - 링크필드의 참조값에 대한 연산만으로 쉽게 삽입/삭제연산을 수행할 수 있다.
    - 순차 선형리스트와는 달리 원소이동현상이 일어나지 않는다.

  
### 1) 단순 연결 리스트(=연결리스트=선형연결리스트=단순연결선형리스트)
: 노드가 하나의 링크 필드에 의해서 다음 노드와 연결되는 구조를 가진 연결 리스트다.

#### (1) 단순 연결 리스트의 노드 삽입 / 삭제 연산
- 삽입연산일 경우, 앞의 노드는 삽입할 노드의 참조값을 저장하고 삽입할 노드는 다음 노드의 참조값을 저장한다.
- 삭제연산일 경우, 앞의 노드에 삭제할 노드의 참조값으로 덮어씌운다. 이때 삭제할 노드는 여전히 다음노드의 참조값을 저장하고 있지만, 삭제할 노드를 연결하는 앞의 노드가 삭제할노드를 가르키지 않기때문에 굳이 삭제할 노드에  null을 저장할 수고를 줄일 수 있다. 이미 의미없는 값이 되었기 때문이다.
- 순차 선형리스트와 달리 단순 연결 리스트의 삽입 연산에서는 물리적 순서를 유지하기 위해서 원소이동현상이 일어나지 않는다.   
#### (2) 단점
시작노드에서 링크를 따라 이동하여 마지막 노드까지 한방향으로만 순회할 수 있는 구조이다. 그렇기 때문에, 현재 노드에서 이전 노드를 접슨(엑세스)하려면 현재 위치에 상관없이 항상 리스트의 첫 번째 노드부터 다시 시작해야한다.

### 2) 원형 연결 리스트
: 단순 연결 리스트에서 마지막 노드가 리스트의 첫번째 노드를 가리키게 하여 리스트의 구조를 원형으로 만든 연결리스트를 원형 연결 리스트라 한다.  

단순연결리스트와는 달리 이전 노드를 접근하기 위해 첫번째 노드부터 다시 시작할 필요가 없다. 원형으로 계속 순회하기 때문에 링크를 따라 계속 순회하면 이전 노드에 접근할 수 있다.
#### (1) 원형 연결 리스트의 삽입 / 삭제 연산
- 삽입 연산 : 마지막 노드의 링크를 NULL로 두는 것이 아니라 첫번째 노드로 연결하는 부분만 제외하고는 단순 연결 리스트에서의 연산과 같다.
- 삭제 연산: 마지막 노드 혹은 첫번째 노드 삭제시 다시 다음 마지막 노드 혹은 첫번째 노드와 연결해야하는 부분만 제외하고는 단순 연결 리스트에서의 연산과 같다.

#### (2) 단점
단순 연결 리스트에서 선행 노드에 접근하기가 어렵다는 점을 개선하여, 원형 연결 리스트를 구성했지만, 원형 연결 리스트에서도 현재 노드의 바로 이전 노드에 접근하려면 전체 리스트를 한바퀴 순회해야하는 문제가 있다. 이러한 문제는 리스트의 링크가 한 방향으로만 되어있어서 반대 방향으로는 순회할 수 없기 때문에 발생한다. 

### 3) 이중 연결 리스트 / 이중 원형 연결 리스트
: 위의 단점을 보완하기위해 양방향으로 순회할 수 있도록 연결한 리스트를 이중 연결 리스트라고 한다. 
- 이중연결리스트의 노드구보 : [ 링크필드(llink/left filed) ][ 데이터필드 ][ 링크핑드(rlink/right filed  ) ] 두 개의 링크 필드와 한개의 데이터 필드로 구성된다.  
=> 오른쪽 링크필드가 오른쪽 노드의 참조값을 저장하고 있고, 왼쪽 링크 필드가 왼쪽 노드이 참조값을 저장하고 있다. 그리고 각각의 링크필드는 양쪽으로 원형으로 순회하고 있기 때문에, 원형 이중 연결 리스트가 된다. 이때 원형으로 순회하고 있지않지만, 양 방향으로 진행된다면, 이중 연결 리스트라고 한다.?

#### (1) 이중 원형 연결 리스트의 삽입 / 삭제 연산
: 삽입/삭제 연산 모두 원형 연결리스트와 같은 방법으로 진행되지만, 양쪽방향으로 모두 진행된다는것이 다른 점이다. 

### +) 자유공간리스트
연결 리스트에서 삽입연산을 하려면 먼저 메모리에서 공백노드를 가져와야하고, 삭제연산에서는 삭제되어 사용하지않는 노드에 대한 메모리공간을 처리해야 한다. 즉, 삽입/삭제 연산시에 메모리할당작업이 필요하다.  
이러한 작업을 사용하지 않은 메모리 공간이 미리 노드의 구조로 나누어져 연결리스트로 만들어져 노드를 할당하거나 혹은 반환받을 수 있다면, 연산과정과 메모리 관리가 효율적으로 이루어질 수 있다.  
이렇게 메모리를 사용하기 전에 미리 노드를 나누어서 연결해 놓은 리스트를 자유공간리스트(Free Space List)라고 한다.  

3.1 Stack
===
: 자료를 순서대로 나열하여 리스트를 구성하는 것 이외에 자료를 나열하는 방법을 제한하는 몇 가지 규칙을 추가하여 리스트를 응용한 자료구조를 만들 수 있다.  

스택 이란 쌓아 올린다는 의미다. 따라서 스택 자료구조라는 것은 접시를 쌓듯이 자료를 차곡차곡 쌓아 올린 쳥태의 구조를 말한다. 즉, 스택은 같은 구조와 크기의 자료를 top이라고 정한 한 곳으로만 쌓을 수 있고, top으로만 접근하도록 제한하여 만든 자료구조다.  

스택에서는 새ㅔ을 통해서 들어온 자료가 일정한 방향으로 쌓인다. 나중에 들어온 자료가 맨 위에 위치하게 되고, 삭제하는 자료도 가장 위에 위치하는 자료이다. 따라서, 스택은 시간 순서에 따라 자료가 쌓이고, 삭제할때는 가장 마지막에 삽입된 자료가 가장먼 먼저 삭제되는 후입선출(LIFO, Last-In-First-Out)의 구조를 가진다.  

스택에서 top을 통한 삽입 연산을 push, top을 통한 삭제연산을 pop라고 한다.   

1) 순차 자료구조방식을 이용한 스택의 구현
--- 
순차 자료구조인 1차원 배열을 이용하여 스택을 구현할 수 있다. 1차원 배열 stack[n]을 사용할 때, n은 배열 크기로서 배열 원소의 갯수를 나타내는데, 이것이 스택의 크기가 된다. 스택에 원소가 쌓이는 순서는 배열의 인덱스(index)로 표현한다. 따라서 스택의 첫번째 원소는 stack[0]에 저장하고, i번째 원소는 stack[i-1]에 저장한다.  

스택의 top을 표현하기 위해서 배열 stack의 마지막 원소의 인덱스 값을 변수 top에 저장한다. 변수 top은 0부터 n-1까지의 인덱스(1~n-1)를 저장하므로, 스택이 초기 상태(공백)일 때 top은 -1을 저장한다. 변수 top값은 삽입 혹은 삭제 연산을 하면서 값이 지속적으로 바뀐다.

2) 연결 자료구조 방식을 이용한 스택의 구현
---
순차 자료구조를 이용한 스택은 배열을 사용하여 구현하기는 쉽지만, 물리적으로 크기가 고정된 배열을 사용하기 때문에 스택의 크기를 변경하기가 어렵고, 메모리의 낭비가 생길 수 있다는 문제가 있다. 이러한 순차 자료구조 방식의 문제는 연결 자료구조 방식을 이용함으로써 해결할 수 있다.  

연결 자료구조 방식의 단순 연결 리스트를 이용하여 스택을 구현하면, 스택의 원소는 연결리스트의 노드가 된다. 스택에 원소를 삽입할 때마다 연결 리스트에 노드를 하나씩 연결한다. 그리고 스택원소들간의 순서는 연결리스트 노드의 링크를 사용하여 표현한다. 스택의 top을 표현하기 위해서 참조 변수 top(리스트 이름?)을 사용한다.  스택이 초기 상태일 경우 top은 null이지만, 삽입할때마다 참조변수의 값이 새로 저장한 노드의 참조값으로 저장하게 된다. 즉, 연결 자료구조 방식은 첫번째 노드에 계쏙 삽입이 되어서 참조변수의 값이 계속 바뀌는 구조이다.

PUSH 일 경우 순차와 마찬가지로 TOP에 마지막원소의 참조값이 저장된다. 즉, PUSH를 할 경우 뒤에 연결되는 것이 아니라 앞에 연결이 된다. POP 삭제 또한 앞에서부터 삭제가 되고, OP 참조값이 변경이 된다. 이렇나 과정은 후입선출 구조 임을 알 수 있다.후입(앞에서 PUSH)선출(앞에서 POP), 즉 이때의 TOP은 순차와는 달리 첫번째 위치임을 의미함을 알 수 있다.?

3.2 Queue
===

1) Queue의 구조
---

큐는 스택과 마찬가지로 삽입과 삭제의 위치와 방법이 제한되어 있는 유한 순서 리스트(Fiinite Ordered List)지만, 스택과 달리 리스트의 한쪽 끝에서는 삽입 작업이 이루어지고, 반대쪽에서는 삭제작업이 이루어져서, 삽입된 순서대로 삭제되는 선입선출(FIFO)의 구조를 가진다. 큐는 한쪽 끝을 나가는 위치(프런트/front)로 정하여 삭제연산만 수행하도록 하였고, 다른 쪽 끝은 들어오는 위치(리어/rear)로 정하여 삽입 연산만 수행하도록 제한한다. 큐에서 프런트 원소는 가장 먼저 큐에 들어온 첫 번째 원소이고, 리어 원소는 큐에 가장 늦게 들어온 마지막 원소이다. 따라서 가장 먼저 들어온 프런트 원소가 가장 먼저 삭제되고, 가장 마지막에 들어온 원소가 리어원소가 되는 선입선출 구조가 된다.

큐의 리어에서 이루어지는 삽입 연산을 인큐(enQueue)라고 하고, 프런트에서 이루어지는 삭제연산을(deQueue)라고 한다. Stack과는 달리 삽입과 삭제연산이 이루어지는 곳이 일치함을 알 수 있다. 

2) 순차 자료구조 방식을 이용한 큐의 구현
---

- 선형큐  
1차원 배열을 사용하여 큐를 구현하게 되면, 배열의 크기는 큐의 크기, 즉 큐에 저장할 수 있는 최대 원소의 개수가 된다. 그리고 첫번째 원소의 인덱스를 저장할 front변수와 저장된 마지막 원소의 인덱스를 저장할 rear변수를 사용한다. 초기 공백 큐의 상태는 front와 rear가 같은 위치에 있는 상태이기 대문에 front변수와 rear변수의 값을 -1로 설정한다. 큐가 포화 상태인 경우는 배열의 마지막 인덱스까지 원소가 저장된 경우이므로 즉, rear의 값이 배열의 마지막 인덱스(n-1)이어야 한다. 포화 상태의 조건은 rear의 값이 n-1 즉, 마지막 인덱스이고, 공백 상태의 조건은 rear = front = -1 ? 인 경우이다.

- 원형 큐  
선형큐 즉, 1차원 배열을 사용한 순차 자료구조 방식에서는 큐가 포화상태가 아닐 경우에만 삽입연산을 수행하도록 정의되어 있다. 그러나, front의 위치가 진짜 이 아닐경우, 빈자리가 있음에도 raer가 n-1이므로 포화상태로 인식한다. 삽입/삭제 연산을 진행하지 않는다. 그렇기에 빈부분을 없애기 위해 앞부분으로 이동시켜 위치를 조정해야한다. 이러한 이동 작업은 큐의 효율성을 떨어 뜨린다.  
이러한 문제를 해결하기 위해 , 원형큐를 사용한다. 원형큐는 1차원배열을 사용하지만 처음과 끝이 연결되어 있다는 차이점이 있다.  
원형큐에서는 초기 공백 상태일 때 front와 rear의 값이 0이 되고, 공백 상태와 포화 상태를 구분하기 위해서 자리 하는 항상 비워둔다. 원형큐에서는 공백 상태 조건은 front = rear가 된다.  rear는 앞으로 이동하면서 원소를 삽입하고, front는 rear가 이동한 방향을 따라가면서 원소를 삭제한다. 원형 큐에서는 배열의 인덱스가 n-1다음에 다시 0이 되어야하므로 사용할 다음 인덱스를 정하기 위해서 나머지 연산자 mod를 사용한다.? 즉, 포화상태인 rear의 다음 위치 ((rear+1) mod n)는 현재의 front위치가 되어 더 이상 원소를 삽입할 수 없는 포화 상태가 된다..?????

3) 연결 자료구조 방식을 이용한 큐의 구현

- 연결큐  
순차자료구조방식을 이용하게되면, 사용 크기가 데한되어 있어서 큐의 길이를 마음대로 변경할 수 없고, 원소가 없을 때에도 항상 처음 크기를 유지하고 있어야 하므로 메모리도 낭비된다. 이러한 문제를 극복하기 위해 연결 자료구조 방식을 이요하여 크기에 제한이 없는 연결큐를 구현한다.  
연결 큐에서 원소는 데이터 필드와 링크 필드를 가진 노드로 구성하며, 첫 번째 노드를 가리키는 참조변수 front와 마지막 노드를 가리키는 참조변수 rear를 사용한다.(참조변수가 2개를 가진다.) 연결큐의 초기 상태는 front와 rear를 NULL로 초기화하여 표현한다. 즉, 둘다 NULL이면 공백 상태임을 알 수 있다. 삽입연산 시 새노드를 생성하여 데이터 필드에 저장하고, 삽입할 새 노드는 마지막 노드가 되어야하므로 링크 필드에 NULL로 저장한다. 이때 공백 상태였을 경우 FRONT, REAR모두 마지막 노드를 가리키고 참조값을 저장한다. 공백상태가 아니었던 경우에는 마지막이었던 노드가 삽입한 노드 의 참조값을 저장하고(마지막 노드 뒤에 새노드를 삽입) REAR 또한 해당 노드를 가리키도록 설정한다.  삭제연산의 경우에는 첫번째 노드를 삭제하고, FRONT가 새로운 첫번째 노드를 가리킨다. 이때 만약에 노드가 남지 않는다면 FRONT와 REAR에 참조된 값을 지우고 NULL로 초기화시켜준다.

- 덱  
덱(Deque)은 큐의 양쪽 끝에서 삽입과 삭제가 모두 발생하는 큐로서, 스택과 큐의 성지릉ㄹ 모두 가지고 있다.  
덱 연산은 스택과 큐의 연산을 모두 가지고 있다. front/rear를 스택의 top으로 생각하여 push,pop연산 모두 각각 가능하다.

3.3 Tree
===
Tree 란?
---
부모 자식을 가진 존재 => 계층이 있고, 그룹이 존재함  
이가 가능한것은 노드가 하나 이상의 child가 존재하기 때문(자식이 없는 노드는 leaf라고 함)  
그렇기에 노드가 하나 이상의 child를 가지면, tree라고 함.  
그리고 child노드가 최대 2개 인 tree는 이진 트리(binary tree) <-> ternary tree  
이진 트리는 다시 binary tree <-> 이진 검색트리 (binary search tree)로 나누어짐 이진 검색트리는 왼쪽 노드 data < 오른쪽 노드 data라는 법칙?을 가지고 있다. 이러한 법칙을 가지고 있으면, 값을 찾기가 수움
또한, balanced(ex, re-black tree/AVL tree) <-> unbalanced 로 나눌수도 있음  
또한, 완전 이진트리로도 나눌수있음 왼쪽부터 완전히 노드가 채워져있는? 트리를 complete binary tree?라고 한다.  
또한, Full binary tree로도 나눌수 있음. 모두 node가 child를 0개 혹은 2개를 가진 트리를 full binary tree라고 한다.  
또한, pervect binary tree로도 있음 모든 node는 child를 2개만 가지고 있고, leaf의 level은 모두 일치한다.(n개의 level을 가지고 있으면, node의 수는 2^n -1개를 가진다.)

1) Tree의 구조
---
리스트와 스택, 큐는 자료들이 선의 형태로 나열되어 있는 구조를 가진 선형 자료구조이지만, 트리는 나열된 구조가 선형이 아닌 자료구조를 비선형 자료구조라고 한다. 트리는 비선형 자료구조 중에서 자료들 간에 계층구조를 가진 계층형 자료구조다. (비선형 - 계층형 자료구조)  
트리를 구성하는 원소(자료)를 노드라고 하고 노드를 연결하는 선을 간선(edge)라고 한다. 부모노드와 자식노드는 간선으로 연결되어 있다. 트리의 시작노드를 루트 노드(Root Node)라 하고 레벨0이 된다. 같은 부모노드의 자식노드들은 서로 형제 노드(Sibling Node)가 된다. 한 노드에서 간선을 따라 루트 노드까지 이르는 경로에 있는 노드들은 모두 그 노드의 조상노드가 된다. 자식노드들은 가가 독립하여 새로운 트리를 구성할 수 있으므로 각 노드는 자식노드 수 만큼의 서브트리를 갖는다.   
한 노드가 가지는 서브트리의 수 즉 , 자식 노드의 수를 그 노드의 차수(degree)라 한다. 그러나, 차수가 0인 노드, 즉 자시기 없는 노드를 리프(Leaf Node)또는 단말 노드라고 한다.그리고 노드의 차수 중에서 가장 큰 차수는 트리의 전체 차수가 된다.  
한 노드의 높이는 루트에서 그 노드에 이르는 경로에 있는 간선의 수가 되고, 노드의 높에 중에서 가장 큰 높이, 즉 최대 레벨이 그 트리의 전체 높이가 된다.  
여러 트리들의 집합을 포리스트(forest)라고 한다. n개의 서브트리를 가진 루트 노드(Root Node)를 제거하면 n개의 분리된 트리가 생기고, 이 트리들은 포리스트가 된다.  

3.3.1 이진트리
===
1) 이진트리의 구조
---
트리의 노드구조를 일정하게 정의하면, 트리의 연산이 단순화 되어 쉬워진다. 그래서 모든 노드의 차수를 2이하로 정하여 전체 트리의 차수가 2 이하가 되도록 만든 것이 이진트리(Binary Tree)다.  
이진트리는 왼쪽 자식노드와 오른쪽 자식노드 2개만을 가질 수 있으며, 공백노드 또한 이진 트리의 노드로 취급한다. 즉, 둘중 자식노드가 한개가 없거나 자식노드가 모두 없는 단말 노드는 공백노드를 자식으로 가진 이진트리이다.  
이진트리에 있는 모든 노드는 왼쪽 자식 노드를 루트로 하는 왼쪽 서브트리와 오른쪽 자식 노드를 루트로 하는 오른쪽 서브 트리를 사지고, 서브트리들 역시 모두 이진 트리여야한다.
- n개의 노드를  가진 이진 트리는 항상 (n-1)개의 간선을 가진다.
- 높이가 h인 이진트리가 가질 수 있는 노드의 최소 갯수는 (h+1)개가 되며, 최대 갯수는 (2^(h+1)-1)개 이다.

2) 이진트리의 분류
---
- 포화이진트리(Full Binary Tree)
모든 레벨에 노드가 꽉차서 포화 상태인 이진 트리를 의미한다. 포화 이진트리의 노드는 위치에 따라 일정한 노드 번호를 붙일 수 있다. 루트 노드를 1번으로 하고, 레벨 별로 왼쪽에서 오른족으로 차례로 번호를 붙인다. 

- 완전 이진 트리(Complete Binary Tree)
완전 이진트리는 높이가 h고, 노드는 최대노드수보다 적을때, 노드 위치가 포화 이진트리의 1번부터 n번까지의 위차가 완전히 일치하는 이진 트리다. 따라서 n+1 ~ (최대 노드수)번까지의 노드는 공백노드가 되는것이 완전 이진 트리이다.

- 편향 이진 트리(Skewed Binary Tree)
이진 트리 중에서 최소 개수의 노드를 가지면서, 왼쪽이나 오른쪽 서브 트리만 가지고 있는 트리를 편향이진트리라고 한다. 오른쪽으로 일직선이거나 왼쪽으로 일직선형태를 가진다.

3) 이진트리의 구현
---
- 순차 자료구조 방식을 이용한 이진트리의 구현  
이진트리를 배열로 표현하는 방법은 높이가 h인 포화 이진트릐의 노드번호를 배열의 인덱스로 사용하여 1차원 배열로 표현하는 것이다. 1차원 배열에서 인덱스 계싼을 간단히 하기 위해서 인덱스 0번을 실제로 사용하지 않고, 비워두고 인덱스 1번에 Root Node를 저장한다. 또한, 부모노드와 지삭노드간의 일정한 규칙을 가지기 때문에 부모노드와 자식노드를 쉽게 찾을 수 있다.

- 연결 자료구조 방식을 이용한 이진트리의 구현  
배열을 이용한 순차자료구조 방식은 쉽게 만들 수 있으며, 인덱스 규치에 따라 자식노드와 부모노드를 찾기 쉽지만, 메모리 공간의 사용에 있어서 완전 이진트리 경우에는 최적의 사용공간 사용이 되지만, 편향 이진트리의 경우에는 많은 공간이 낭비 된다. 이런 낭비는 삽입과 삭제 연산이 비효율적이라는 순차 자료구조 방식 때문에 연결 자룍구조 방식을 사용한다.  
이진트리를 연결자료구조 방식으로 표현하기 위해서 사용하는 노드의 구조는 데이터필드 1개와 링크필드가 오른쪽 왼쪽 2개로 구성되어 있어야 한다. 이때 링크 필드에 저장되는 참조값은 자식 노드이고 없을 경우에는 링크 필드에 null로 설정한다.  

4) 이진트리의 순회
---
트리를 사용하여 자료를 계층적인 구조로 저장하고, 사용하기 위해서는 트리에 있는 모든 노드를 방문하는 방법이 필요하다. 이진 트리에 있는 모든 노드를 한번씩 모두 방문하여 노드가 가지고 있는 데이터를 처리하는 것을 순회(Traversal)라고 한다.   
- 전위 순회 (현재(전위) => 왼쪽 => 오른쪽 : DLR) = Preorder Traversal   
: 현재 노드 부터 시작해서 왼쪽 서브 트리로 이동한다.
- 중위 순회 (왼족 => 현재(중위) => 오른쪽 : LDR) = Inorder Traversal  
: 현재노드의 왼쪽 단말 노드부터 시작해서 현재노드로 이동하고, 오른쪽 서브트리로 간다.
- 후위 순휘 (왼쪽 => 오른쪽 => 현재(후위) : LRD) = Postorder Traversal  
: 현재노드이 왼쪽 서브트리의 단말 노드에서 오른쪽 서브트리로 시작하고 현재노드를 마지막으로 간다.

3.3.2 이진 탐색 트리
===
1) 이진 탐색 트리의 구조
---
이진트리는 트리를 효율적으로 사용하기 위해서 일정한형태로 정의한 것이다. 그리고 탐색을 위한 자료구조로 이진 트리를 사용하기 위해서 저장할 데이터의 크기에 따라 노드의 위치를 정의한 것이 이진 탐색 트리(Binary Search Tree)다. 
1. 모든 원소는  서로 다른 유일한 키(탐색키)를 갖는다.
2. 왼쪽 서브트리에 있는 우너소의 키값은 그 루트의 키값보다 작다.
3. 오른쪽 서브트리에 있는 원소의 키값은 그 루트의 키값보다 크다. (왼쪽 서브트리의 키값 < 루트의 키값 <  오른쪽 서브트릐의 키 값)
4. 왼쪽 서브트리와 오른쪽 서브 트리도 이진 탐색 트리다.
2) 이진 탐색 트릐의 연산
---
- 탐색 연산 :  
탐색은 항상 Root Node에서 시작하므로, 먼저 키값x와 루트노드의 키값을 비교한다. 루튼드에서 원소를 찾을때까지 단말노드로 내려간다.
    - ( 키값 x = 루트노드의 키값 )인 경우 : 원하는 원소를 찾았으므로 탐색연산 성공
    - ( 키값 x < 루트노드의 키값 )인 경우 : 루트 노드의 왼쪽 서브 트리에 대해서 탐색 연산 수행
    - ( 키값 x > 루트노드의 키값 )인 경우 : 루트 노드의 오른쪽 서브 트리에 대해서 탐색 연산 수행
- 삽입 연산 :  
이진 탐색 트리에 원소를 삽입하려면 먼저 같은 원소가 있는지 확인하기 위해서 탐색을 해야한다. 탐색에 성공하면, 이미 같은 원소가 있으면 삽입연산을 수행하지 않고, 실패하면, 크기롤 비교하여 마지막 단말노드까지 key값이 같은 원소가 없는 것이므로 해당 단말노드의 자식 노드에 원소를 삽입한다. 오른쪽인지 왼쪽인지는 키값을 비교연산을 통해서 선택한다.
- 삭제 연산 :  
삽입과 마찬가지로 탐색 후 삭제를 해야한다. 삭제 할 노드는 자식 노드의 수에 따라 결정된다.
    - 삭제할 노드가 단말노드인 경우 (차수가 0 인 경우)  
    : 삭제할 노드가 단말 노드인 경우에는 노드를 삭제하고, 부모노드의 링크 필드를 null로 설정한다.
    - 삭제할 노드가 한 개의 자식 노드가 잇는 경우 (차수가 1인경우)  
    : 해당 노드를 삭제하고, 자식노드를 부모노드 위치로 올려준다.
    - 삭제할 노드가 두 개의 자식 노드가 있는 경우 (차수가 2인 경우)   
    : 자손노드의 키값은 이진 탐색 트리 특성에 따라서 왼쪽 서브 트리에 있는 노드을의 키값보다 커야하고, 오른쪽 서브트리에 있는 노드들의 키값보다는 작아야한다. 그러므로 후계자 노드는 삭제할 조상노드의 왼쪽 서브트리에서 가장 큰 자손노드 또는 오른쪽 서브트리에서 가장 작은 자손 노드가 되어야 한다.  
    이진 탐색트리의 정의를 생각해봤을 때, 왼쪽 서브트리에서 가장 큰 키값의 노드를 탐색하는 작업은 왼쪽 서브트릐의 오른쪽 링크를 따라 계속이동하여 오른쪽 링크 필드가 null인 노드, 즉 가장 오른쪽에 있는 노드를 찾는 작업이 된다. 그리고 서브트리에서 가장 작은 키 값의 노드를 탐색하는 작업은 오른 쪽 서브트리에서 왼쪽 링크를 따라 계속 이동하여 왼쪽 링크 필드가 null인 노드, 즉 가장 왼쪽에 있는 노드를 찾는 작업이 된다.

3.4 Heap
===
Heap이란>
---
Heap이란 최댓값이랑 최솟값을 빠르게 검색하게 하기위한 완전이진트리를 기본으로 한 자료구조.  
최소힙 : 가장 작은값을root에 위치하게함 / 최대힙:가장 높은 값을 root에 위치하게 함  
최소힙에 노드를 삽입하기 위해서는 완전 이진트리를 구조를 벗어나지 않기 위해 leaf에 먼저 삽입한다. 자신 부모노드와 비교해서 값이 작으면 교체한다.   
최소힙에서 노드를 삭제하기 위해서는, 완전이진트리의 마지막 노드를 가져와서 위에 삽입한다. 그리고 이번에는 자식 노드와 비교해서 값이 크면 교체한다.   
최대 O(logn)의 시간이 걸림 왜냐면 한번 갈수록 가야할길이 절반으로 줄기 때문

1) Heap의 구조
---
힙은 완전이진트리에 있는 노드 중에서 키 값이 가장 큰 노드나 키값이 가장 작은 노드를 찾기 위해서 만든 자료구조이다. 키 값이 가장 큰 노드를 찾기 위한 힙을 최대 힙(Max Heap)이라 하고, 키 값이 가장 작은 노드를 찾기 위한 힙을 최소 힙(Min Heap)이라 한다.  
최대 힙은 부모 노드의 키 값이 자식녿의 키 값보다 항상 크거나 같은 크기의 관계 즉, 부모 >= 자식 키값의 관계를 가지는 노드들의 완전 이진트리다. 그러므로 최대 힙에서는 가장 큰 노드가 루트 노드가 된다. 최소 힙은 부모노드의 키 갑이 자식 노드의 키값보다 작거나 같아야한다. 부모 <= 자식 노드 키값의 관계를 가지는 노드들의 완전 이진트리다. 그러므로 최소 힙에서는 키 값이 가장 작은 노드가 루트노드가 된다. 일바넞긍로 힙은 최대 힙을 의미하며, 같은 키값의 노드가 중복 될 수 있다.

2) Heap의 연산
---
1. 삽입 연산  
힙에서의 삽입연산은 완전이진트리의 형태를 유지하기 위해서 현재의 마지막 노드의 다음 자리를 확장하여 만든 자리에 삽입할 노드를 임시로 젖아한다. 그리고 키값의 관계가 최대 힙이 되도록 재구성하기 위해 삽입할 노드의 키값과 부모노드의 키값을 비교한다. 힙에서의 삽입연산은  어느 위치에서든지 부모노드를 쉽게 찾아야 하기 때문에 순차 자료 구조 방식을 이용하여 힙을 표현하고, 배열 인덱스 관계를 이용하여 부모노드를 찾는다.
2. 삭제 연산  
힙에서의 삭제연산은 언제나 루트노드에 있는 원소를 삭제하여 반환한다. 그러므로 최대 힙에서의 삭제연산은 키값이 가장 큰 원소를 삭제하여 반환한다. 최소힙은 가장 작은 원소를 삭제하여반환한다. 그 후에는 완전이진트리여아하기 때문에 가장 마지막 노드가 있던 자리를 제거하고, Root Node에 임시 저장한다. heap의 규칙을 지켜야하기 때문에 자식노드와 비교해서 재구성작업을 해야한다.

4)순차자료구조 방식을 이용한 힙의 구현
---
1차원 배열의 순차 자료구조방식을 이용하면 배열 인덱스 관계를 바탕으로 부모노드를 쉽게 찾을수 있다. 

3.5 Tries
===
Tries란?
---
문자열에서 검색을 빠르게 하기위해 고안된 자료구조.
루트 값이 비고, 자식들부터 문자열이 아닌 단어 한글자만 가지고있다. 그리고 차례로 내려오면서 지나간 단어를 연결하면, ex copy라는 문자열이 완성된다. 그리고 y라는 node에는 copy라는 문자열의data가 담겨져 있다. 그냥 문자열을 노드에 저장하면 문자열 길이 M의 시간 까지 합해서 시간이 M(log n)이 걸리지만, tries처럼 하면 o(M)의 시간밖에 걸리지 않는다

3.6 Graph
===
Graph란?
---
사실 tree는 graph의 한종류이다.? tree는 graph에서 루트가 있고, 사이클이 없으며, 아래로만 흐르는 한방향이며, 들어오는 곳이 한개이다.? 그래프는 tree와는 달리 제약이 없다.  
그래프는 방향이 있을수도 없을수도 있다. tree는  Directed graph이다. 방향 그래프는 셀프엣지라고 자기자신을 가리키루도 있다.   
방향그래프는 cyclic(하나 이상의 사이클 있는 그래프) <-> Acyclic  
Graph를 표현하는 방법에는 2가지가 있음  
- Adjacency Matrix : 2차원 배열에 나열하는 방법  
그래프를 표(2차원 배열)에 표현하는 방법. 즉, 연결되면 1로 표현하고, 아니면 0으로 표현한다.
- Adjacency List : 배열과 Linked List로 나열하는 방법  
배열방에 각각 Linked List가 존재하고, 해당 노드에 인접한 노드는 Linked List에 순서 상관없이 나열함 => 노드의 갯수가 n개이면, list의 총 노드는 2n개가 발생함   

Graph 검색 방법
---
- Depth - First - Search(DFS : 깊이 우선 방법) :  
  tree 검색 방법이었던 inorder,preorder,postorder들도 DFS에 속한다.  즉, child노드 이어가면서 leaf까지 가고 다시 올라가서 다시 아래로 내려가는 같은 방법으로 가능 방법이다.   
  Stack을 이용해 구현 : 시작 노드를 stack에 넣고, 시작노드를 출력할때, 자식노드들을 stack에 입력하고, 그중에 노드 한개를 출력할때 해당 노드의 자식 노드들을 입력함을 반복한다. stack이기 때문에 깊이 우선 방식이ㅏㄷ..응? 단, 한번 입력했던 노드는 다시 넣지 않는다.  
  재귀호출(Recursion)을 이용해 구현 : 시작노드를 호출하면, 자식노드를 호출하고 재귀호출이 계속 반복한다. 이때, 자식노드들을 호출할때, 정방향으로 우선적으로 호출한다. 또한, 자식노드들(a,b_) 중 정방향의 노드(a)를 우선 호출하여 해당 자식 노드들(b,c)을 호출하는데 여기에 형제 노드이면서 자식 노드인 (b)가 먼저 호출 되는것 이 아닌 어느 쪽부터 먼저 입력했는가를 우선적으로 호출???? 한다. 
- Breadth - First - Search(BFS : 넓이 우선 방법) : level단위로 형제노드들을 검색하는 방법  
  Queue를 이용해 구현 : 시작노드를 queue에 입력하고, 출력할때, 자식노드들을 queue에 입력하고, 반복한다. 여기서 후입선출이 아닌 선입선출이라는 점이 다르다. 이 점이, 넓이 우선 방식이다.엥????? DFS와 마찬가지로 한 번 넣었던 노드는 다시 입력하지 않는다.  

그래프에는 tree와는 달리 부모 자식 관계가 없다.


1) 그래프의 구조
---
그래프는 연결되어 있는 원소간의 관계를 표현하는 자료구조 이다. 그래프는 선형자료구조나 트리가 표현할 수 없는 모든 연결구조들을 표현할 수 있기 때문에 여러분야에서 폭 넓게 사용된다.  
그래프는 연결할 객체를 나타내는 정점(vertex)과 객체를 연결하는 간선(edge)의 집합으로 구성된다.

2) 그래프의 종류
---
그래프는 방향성과 연결 정도에 따라 여러 형태가 있다.
- 무방향 그래프(Undirected Graph) :  
무방향 그래프는 두 정점을 연결하는 간선에 방향이 없는 그래프다. 무 방향 그래프에서 정점 a와 정점 b을 연결하는 간선을 (a,b)로 표현하는데, 이때, (a,b)와 (b,a)는 방향이 없는 무방향 그래프이므로 같은 간선으로 취급한다. 무방향그래프 G를 정점의 집합 V(G) = { a,b }와 간선의 집합 E(G) = { (a,b) }로 표현할 수 있다.
- 방향 그래프(Directed Graph) :   
방향 그래프는 다이그래프(digraph)라고도 하는데 간선에 방향이 있는 그래프다. 방향 그래프에서 간선은 a -> b 를 < a,b >로 표현하고 화살표호 나타낸다. 그리고 a를 꼬리(trail), b를 머리(head)라고 한다. 방향그래프는 간선에 방향이 있기 때문에, < a,b >와 < b,a >는 서로 다른 간서이 된다. 방향그래프 G를 정점의 집합 V(G) = { a,b }와 간선의 집합 E(G) = { < a,b >,< b,a > }로 표현할 수 있다.
- 완전 그래프(Complete Graph) :  
완전 그래프는 한 정점에서 다른 모든 정점을 연결되어 최대의 간선 수를 가진 그래프다. 정점이 n개인 무방향 그래프의 최대 간선 수는 n(n-1)/2개 이며, 방향 그래프의 경우에는 n(n-1)개가 된다. 
- 부분 그래프(subgraph) :  
원래의 그래프에서 일부의 정점이나 간선을 제외하여 만든 그래프를 부분그래프라고 한다. 그렇기에 부분그래프의 정점 집합은 원래그래프의 정점 집합에 포함되고, 부분그래프의 간선 집합은 원래 그래프의 간선 집합에 포함되는 포함 관계를 가진다.
- 가중 그래프(weight graph) :  
정점을 연결하는 간선에 가중치를 할당하는 그래프를 가중 그래프를 또는 네트워크라고 한다.

3) 그래프 용어
---
두 정점 a,b가 연결되어 간선(a,b)가 있을 때, 두 정점을 인접되어 있다고 하고, 간선은 두 정점에 부속되어 있다고 한다.  
정점에 부속되어 있는 간선의 수를 차수(degree)라고 한다. 방향그래프에서는 정점에 부속된 간선의 방향에 따라 진입차수(in-degree)와 진출차수(out-degree)가 생긴고, 정점을 머리로 하는 간선의 수는 진입차수가 되고, 정점을 꼬리로 하는 간선의 수는 진출차수가 된다. 방향그래프에서의 정점의 차수는 진입차수와 진출차수의 합한 값이다.  
그래프에서 간선을 따라갈 수 있는 길을 순서대로 나열한것, 즉 정점 a에서 b까지 간선으로 연결된 정점을 순서대로 나열한 리스트를 정점 a에서 b까지의 경로(path)라고 하고, 경로를 구성하는 간선의 수는 경로 길이(Path Length)가 된다. 모든 다른 정점으로 구성된 경로를 단순 경로라고 한다. 단순경로중에서 경로의 시작 정점과 마지막 정점이 같은 경로를 사이클이라 한다. 방향그래프에서 사이클이 없는 그래프를 DAG(Directed Acyclic Garph)라고 한다.  
그래프에서 두정점 a에서 b까지의 경로가 있으면, 정점 a와 b가 연결되었다고 한다. 서로다른 모든 쌍의 정점들 사이에 경로가 있는 그래프, 즉 떨어져 있는 정점이 없는 그래프를 연결 그래프(Connected Graph)라고 한다. 트리는 사이클이없는 연결 그래프이다. 이와 반대로 같이 연결되지 않은 정점이 있는 그래프를 단절 그래프(Disconnected Graphh)라고 한다.

4)그래프의 구현
---
그래프를 구현하기 위해서는 정점에 대한 집합과 정점에 부속된 간선의 집합을 표현해야 한다. 그래프를 표현하는 방법은 순차 자료구조 방식을 이용하는 2차원 배열의 인접 행렬(Adjacent Matrix)방법과 연결 자료구조 방식인 연결리스트를 사용하는 인접 리스트(Adjacent List)방법이 있다.

1. 순차자료구조 방식을 이용한 그래프의 구현 : 인접행렬  
그래프를 구성하는 간선의 유무를 저장하는 방법으로 정점의 수에 대한 정방행렬을 사용한다. n개의 정점을 가진 그래프는 nXn 정뱅행렬을 사용하고, 두 정점이 인접하면 1 아니면 0으로 표현한다. 이런 방법으로 그래프를 표현한 행렬을 인접 행렬이라 한다.  
자기자신으로의 자체 간선은 있을 수 없으므로 대각선을 항상 0 값을 가진다. 무방향 그래프에서는 대각선을 중심으로 양쪽은 값이 항상 같기 때문에 대칭을 이룬다.   
방향그래프에서는 서로 다른 간선으로 취급하기 때문에, 대칭을 이루지 않는다. 행 i의 합은 정점 i의 진출차수가 되고, 열 i의 합은 정점 i의 진입차수가 된다.   
n개의 정점을 가지는 그래프를 nXn인접행렬로 표현하면, 간선의 개수에 상관없이 항상 nXn개의 메모리를 사용하기 때문에 메모리 낭비 문제가 발생한다.
2. 연결 자료구조 방식을 이용한 그래프의 구현 : 인접 리스트  
각 정점에 대한 인접 정점들을 연결리스트로 만드는 것이다. 리스트의 각 노드는 정점을 저장하는 필드와 다음 인접 정점을 연결하는 링크 필드로 구성한다. 어떤 정점의 연결리스트는 그 정점에 인접한 정점의 수 만큼, 즉 그 정점의 차수만큼의 노드가 연결되어 있다. 리스트 내의 노드는 저장하는 정점에 대해서 오름차순으로 연결한다. 각 정점에 대한 참조변수를 배열로 구성하고, 각 정점에 대한 헤드 노드는 인접 정점의 노드 번호에 대한 오름차순으로 정렬하고 연결한 리스트를 가리킨다.  
n개의 정점과 e개의 간선을 가진 무방향 그래프에 대한 인접 리스트는 n개의 헤드노드 배열과 2e개의 노드가 필요하다. 방향그래프의 경우, 크기가 n인 헤드 노드배열이 필요하고, 각 헤드노드에 연결괴는 노드의 수는 각 정점 진출차수가 된다.

5) 그래프의 순회
---
하나의 정점에서 시작하여 그래프에 있는 모든 정점을 한번씩 방문하는 것을 그래프 순회 또는 그래프 탐색이라 한다. 

1. 깊이 우선 탐색 (DFS, Depth First Search) 
: 깊이 우선 탐색은 시작 정점에서 한 방향으로 갈 수 있는 가장 먼 경로까지 깊이 탐색해가다가 더 이상 갈곳이 없으면 가장 마지막 만났던 갈림길 간선이 있는 정점으로 되돌아와서 다른 방향의 간선으로 캄색을 계속함으로써 모든 정점을 방문하는 순회 방법이다. 가장 마지막에 만났던 갈림길 간선의 정점으로 가장 먼저 되돌아가 다시 깊이 우선 탐색을 반복해야 하므로 후입 선출 구조의 스택을 사용한다.  
    (1)시작 정점 X를 결정하여 방문  
    (2)정점 X에 인접한 정점 중에서  
     - 방문하지 않은 정점 Y가 있으면, 정점 X를 스택 PUSH하고 Y를 방문한다. 그리고 Y를 X로 설정하고 다시 (2)을 반복한다.
     - 방문하지 않은 정점이 없으면, 스택을 POP하여 구한 가장 마지막 방문 정점을 X로 설정하고, 다시 (2)를 수행한다.  

    (3) 스택이 공백이 될때까지 (2)를 반복한다.  
각 정점들에 대해서 방문 여부를 표시하기 위해서 배열을 사용한다. 그래프의 정점 갯수를 배열의 크기로 하고, 모든 배열의 요소를 FALSE로 초기화 하고, 방문 할때마다 정점에 대한 배열요소값을 TRUE로 설정한다.  
    > 탐색과정  
    ㄱ) 초기상태 : 배열을 FALSE로기화하고 공백 스택을 생성한다.  
    ㄴ) 정점 A 깊이 우선 탐색을 시작한다. 정점 A에 A와 인접한 정점증중에서 방문하지 않은 B,C가 있으므로 A를 스택에 PUSH하고, 인접 정점 b와 c중에서 오름차순으로 b를 선택하여 탐색을 계속한다. 이때 방문한 A는 Treu값으로 변경한다.  
    ㄷ) B에 방문하지 않은 인접 정점 D,E가 있으므로 B를 스택에 PUSH하고, 오름차순에 따라 D를 선택하여 탐색을 계속한다  
    ㄹ) 이러한 과정을 계속 방문하다가, 정점 C에서 방문하지 않은 인접정점이 없으므로 마지막 정점으로 돌아가기위해 스택을 POP하여 받은 정점 E에 대해서 다시 방문하지 않은 정점이 있는지 확인한다.  
    ㅁ) ㄹ과정을 반복하면서, 계속 POP하여 스택이 공백이므로 깊이 우선 탐색을 종료한다.
2. 너비 우선 탐색(BFS,Breadth First Search)  
: 너비 우선 탐색은 시작 정점으로부터 인접한 정점들을 모두 차례로 방문한 후 방문 했던 정점을 다시 시작점으로 하여 인접한 정점들을 차례로 방문하는 방법으로, 가까운 정점들을 먼저 방문하여 멀리있는 정점들은 나중에 방문하는 순회 방법이다. 선입선출 구조를 갖는 큐를 사용한다.  
    (1) 시작정점x를 결정하여 방문  
    (2) 정점 x에 인접한 정점들 중에서  
     - 방문하지 않은 인접정점이 있으면 차례로 방문하면서 큐에 enQueue한다.
     - 방문하지 않은 인접정점이 없으면 큐를 deQueue하여 구한 정점을 x로 설정하고, 다시 (2)를 반복한다.  

    (3) 큐가 공백이 될때까지 (2)를 반복한다.  
정점들에 대한 방문여불르 표시하기 위해서 배열을 사용한다.   
    > 탐색과정  
    ㄱ) 초기상태 : 배열을 FALSE로기화하고 공백 큐를 생성한다.  
    ㄴ) 정점 a를 시작으로 너비 우선 탐색을 시작한다. 정점 a에 방문하지 않은 모든 인접 정점 b,c를 방문하고 큐에 enQueue한다. a의 값을 true로 변경한다. 또한, 방문하지않은 b,c를 true로 변경한다.  
    ㄷ) 다음 정점을 찾기 휘해서 큐를 deQueue하여 B를 구하고, 이러한 과정을 반복하여 큐가 공백이되면, 너비 우선 탐색을 종료한다.  
6) 신장 트리와 최소 비용 신장 트리
---
1. 신장트리  
그래프의 관점에서는 트리는 사이클이 없는 단순연결그래프이다. n개의정점으로 이루어진 무방향 그래프 G에서 n개의 모든 정점과 n-1개의 간선으로 만들어진 트리를 신장트리(Spanning)라고 한다.  
연결그래프에서 순회를 하면 n-1개의 간선을 이동하면서 모든 정점을 방문하게 되므로 신장트리를 생성하게 된다. 깊이 우선탐색을 이용하여 생성된 신장트리를 깊이 우선 신장(Depth First Spanning Tree)라 하고, 너비 우선 탐색을 이용하여 생성된 신장트리를 너비 우선 신장 트리(Bredth First Spanning Tree)라고 한다.  
2. 최소 비용 신장트리  
가중치 그래프에서 간선에 주어진 가중치는 비용이나 거리,시간을 의미하는 값이 될 수 있다. 따라서 무방향 가중치 그래프에서 신장트리의 비용은 신장트리를 구성하는 간선들의 가중치의 합이되는데, 가중치의 합이 최소인 신장트리를 최소 비용 신장 트리(Minimum Cost Spnning Tree)라고 한다. 최소 비용신장트리를 만들기 위해 kruskal이 만든 알고리즘과 prime이 만든 알고리즘을 주로 사용한다. 
    - Kruskal 알고리즘  
    해당 알고리즘은 가중치가 높은 간서을 제거하면서 최소 비용 신장트리르 만드는 Kruskal 알고리즘1과 가중치가 낮은 간선을 삽입하면서 최소 비용 신장트리를 만드는 Kruskal알고리즘2가 있다.  
        (1) Kruskal알고리즘1  
        ㄱ. 그래프 g의 모든 간선을 가중치에 따라 내림차순으로 정리한다.
        ㄴ. 그래프 g에서 가중치가 가장 높은 간선을 제거한다. (이때, 정점을 그래프에서 분리시키는 간선은 제거할 수 없다. 이런경우에는 그 다음 높은 간선을 제거한다.)  
        ㄷ. 그래프 g에 n-1개의 간선만 남을때까지 (2)를 반복한다.  
        ㄹ. 그래프에 n-1개의 간선이 남게 되면 최소 비용 신장트리가 완성된다.  
        (2) Kruskal알고리즘2
        ㄱ. 그래프 g의 모든 간선을 가중치에 따라 오름차순으로 정리한다.
        ㄴ. 그래프 g에서 가중치가 가장 작은 간선을 삽입한다.. (이때, 삽입하면 사이클을 형성시키는 간선은 삽입할수없고, 그 다음 작은 간선을 삽입한다.)  
        ㄷ. 그래프 g에 n-1개의 간선만 남을때까지 (2)를 반복한다.  
        ㄹ. 그래프에 n-1개의 간선이 남게 되면 최소 비용 신장트리가 완성된다.  
    - Prime 알고리즘  
    해당 알고리즘은 간선을 정렬하지 않고, 하나의 정점에서 시작하여 트리를 확장해 나가는 방법이다.  
        ㄱ. 그래프 g에서 시작 정점을 선택한다.  
        ㄴ. 선택한 정점에 부속된 간선중에서 가중치가 가장작은간선을 연결하여 트리를 확장한다.  
        ㄷ. 이전에 선택한 정점과 새로 확장한 정점에 부속된 모든 간선중에 가장 작은 간선을 삽입한다.(이때까지 선택한 정점과 확장한 정점(누적된 정점)중에서 부속된 간선들에서 고른다.) 이때 사이클을 형성하는 간선은 삽입할 수 없다. 이런 경우에는 다음 작은 간선을 삽입한다.  
        ㄹ. 그래프 g에 n-1개의 간선만 남을때까지 (2)를 반복한다.  
        ㅁ. 그래프에 n-1개의 간선이 남게 되면 최소 비용 신장트리가 완성된다.  

4.정렬(Sort)
===
1) 정렬의 개념
---
순서없이 배열되어 있는 자료들을 작은 것부터 큰 것 순서의 오름차순(ascending)이나 큰 것부터 작은 것 순서의 내림차순(descending)으로 재배열하는 것을 의미한다. 자료를 정렬하는데 사용하는 기준이 되는 특정 값을 키(key)라고 한다.   
[ 정렬 방법의 분류 ]
- 실행 방법에 따른 분류  
정렬은 실행하는 방법에 따라 비교식 정렬(Comparative Sort)과 분산식 정렬(Distribute Sort)로 구분할 수 있다. 
    - 비교식 정렬 방법은 비교하고자 하는 각 키 값들을 한 번에 두 개씩 비교하여 교환하는 방식으로 정렬을 실행한다.  
    - 분산식 정렬은 키 값을 기준으로 하여 자료를 여러 개의 부분집합으로 분해하고, 각 부분집합을 정렬함으로써 전체를 정렬하는 방식으로 실행한다.
- 정렬 장소에 따른 분류  
컴퓨터에서 수행되는 정렬은 컴퓨터 메모리 내부에서 정렬하는 내부정렬(Internal Sort)과 메모리의 외부인 보조 기억 장치에서 정렬하는 외부정렬(External Sort)로 분류할 수 있다.
    - 내부정렬 : 내부 정렬은 정렬할 자료를 메인 메모리에 올려서 정렬하는 방식으로 정렬 속도가 빠르지만, 정렬할 수 있는 자료의 양이 메인 메모리의 용량에 따라 제한된다.   
        (내부 정렬을 사용하는 정렬방식)
        1. 교환방식 : 키를 비교하고, 교환하여 정렬하는 방식(선택 정렬, 버블 정렬, 퀵 정렬)
        2. 삽입방식 : 키를 비교하고 삽입하여 정렬하는 방식(삽입정렬, 셀 정렬)
        3. 병합방식 : 키를 비교하고, 병합하여 정렬하는 방식(2-way 병합, n-way 병합)
        4. 분배방식 : 키를 구성하는 값을 여러 개의 부분집합에 분배하여 정렬하는 방식(기수 정렬)
        5. 선택방식 : 이진 트리를 사용하여 정렬하는 방식(힙 정렬, 트리 정렬)
    - 외부 정렬 : 외부정렬은 대용량의 보조 기억 장치를 사용하기 때문에 내부 정렬보다 속도는 떨어지지만, 내부 정렬로 처리할 수 없는 대용량의 자료를 정렬 처리할 수 있다.  
        1. 병합방식 : 파일을 부분 파일로 분리한 후 각각을 내부 정렬 방법으로 정렬하여 병합하는 정렬방식(2-way 병합, n-way 병합)

여러가지 정렬 방법 중에서 어떤 방법을 사용할 것인지는 사용하는 시스템의 특성, 정렬할 자료의 양, 자료들의 정렬 전 상태, 정렬에 사용하는 기억 공간과 실행 시간 등의 조건에 따라 결정해야 한다. 같은 조건에서 정렬방법의 효율성을 비교하는 일반적인 기준은 원소에 대한 비교횟수와 이동횟수가 된다. 

2) 선택정렬(Selection Sort)
---
선택정렬은 전체 원소들 중에서 기준 위치에 맞는 원소를 선택하여 자리를 교환하는 방식으로 정렬한다. 전체 원소중에서 가장 작은 원소를 찾아서 선택하고  첫번째 원소와 자리를 교환한다. 그 다음 두 번째로 작은 원소를 찾아 선택하여 두번째 원소와 자리를 교환하고, 차례대로 교환하는 과정을 마지막까지 반복하면서 선택 정렬을 완성한다.

3) 버블 정렬(Bubble Sort)
---
버블 정렬은 인접한 두개의 원소를 비교하여 자리를 교환하는 방식으로, 첫번째 원소부터 마지막 원소까지 반복하면 가장 큰 원소가 마지막자리로 정렬하게 된다. 마지막을 제외한 나머지 원소 중에서 이러한 과정을 반복하고, 나머지 원소가 없어지면 버블정렬을 완성한다. 첫번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서, 맨 마지막 자리로 이동하는 모습이 물방울 모양과 같다고해서 버블 정렬이라고 한다.

4) 퀵 정렬(Quick Sort)
---
퀵정렬은 정렬할 전체 원소에 대해서 정렬을 수행하지 않는다. 먼저 기준값을 중심으로 전체 원소들을 왼쪽 부분집합과 오른쪽 부분집합으로 분할(divide)한다. 왼쪽 부분집합에는 기준값보다 작은 원소들을 이동시키고, 오른쪽 집합에는 기준값보다 큰 원소들을 이동시킨다. 이때 사용하는 기준값을 피봇(pivot)이라고 하는데, 일반적으로 전체 원소중에서 가운데에위치한 원소를 피봇으로 선택한다. 
퀵정렬은 다음의 두 가지 기본작업을 반복 수행하여 완성한다.   
    1. 분할(divide) : 정렬할 자료들을 기준값을 중심으로 2개의 부분집합으로 분할한다.  
    2. 정복(conquer) : 부분집합의 원소들 중에서 기준값보다 작은 원소들은 왼쪽 부분집합으로, 기준값보다 큰 원소들은 오른쪽 부분집합으로 정렬한다. 부분집합의 크기가 1 이하로 층분히 작지 않으면 순환호출?을 이용하여 다시 분할한다.  
분할 작업을 순환적으로 반복하면서 피봇의 왼쪽 부분집합과 오른쪽 부분집합을 정렬하는 방법을 반복하면서 전체 원소들을 정렬한다. 부분집합으로 분할하기 위해서 L과 R을 사용한다. 왼쪽 끝에서 오른쪽으로 움직이면서 크기를 비교하여 피봇보다 크거나 같은 원소를 찾아 L로 표시하고, 오른쪽 끝에서 왼쪽으로 움직이면서  피봇보다 작은 원소를 찾아 R로 표시한 후에 두 원소를 서로 교환한다. L과 R이 만나면 피봇과 R의원소를 서로 교환하고 피봇의 위치를 확정한다. 만나지 않으면, L과 R을 서로 교환하고, 피봇의 위치를 확정한다. 피봇의 확정된 위치를 기준으로 만들어진 왼쪽 부분집합과 오른쪽 부분집합에 대해서 퀵정렬을 순환적으로 반복수행하고, 부분집합의 크기가 1 이하가 되면 퀵정렬을 종료한다.   
퀵정렬은 버블정렬은 인접한 두개의 원소를 비교하여 자리를 교환하기 때문에 원소가 이동하는 거리가 1이되어 자기 자리를 찾기까지 비교횟수와 자리교환횟수가 많음점을 개선하여 자기자리에 최대한 가까이 이동시켜서 비교횟수와 자리교환횟수를 줄인 정렬 방법이다.

5) 삽입 정렬(Insert Sort)
---
삽입 정렬은 정렬되어 있는 부분 집합에 정렬할 새로운 원소의 위치를 찾아 삽입하는 방법이다. 정렬할 자료가 두 개의 부분집합 S(Sorted)와  U(Unsorted)로 나뉘어 있다고 생각한다. 앞부분 원소부터 정렬을 수행하면서,  정렬된 앞부분의 원소들은 부분 집합 S가 되고,  아직 정렬되지 않은 나머지 원소들은 부분 집합 U가 된다. 정렬되지 않은 부분집합 U의 원소를 하나씩 꺼내어 이미 정렬되어 있는 부분집합 S의 마지막 원소부터 비교하면서 위치를 찾아 삽입하여 부분집합 S의 원소는 하나씩 늘리고 부분 집합 U의 원소는 하나씩 줄인다. U의 원소를 모두 삽입하여 공집합이 되면 삽입 정렬이 완성된다.  
초기상태 : 첫 번째 원소는 정렬되어 있는 부분집합 S로 생각하고, 나머지 원소들은 정렬되지 않은 원소들의 부분집합 U로 생각한다. 
1. U의 첫번째 원소를 S의 마지막 원소와 비교하여 S집합에 정렬하여 삽입한다.   
2. U의 첫번째 원소을 S의 마지막 원소와 비교하고, 마지막보다 크다면, 뒤에 두어 정렬을 마치지만, 만약 작다면 S의 그 전 순서인 원소와 비교하여 삽입한다.  
3. 해당 과정을 U가 공집합이 될때까지 반복한다. 

6) 셸 정렬(Shell Sort)
--- 
셸 정렬(Shell Sort)은 일정한 간격(interval)으로 떨어져 있는 자료들끼리 부분 집합을 구성하고, 각 부분집합에 있는 원소들에 대해서 삽입 정렬??을 수행하는 작업을 반복하면서 전체 원소들을 정렬하는 방법이다. 전체 원소에 대해서 삽입 정렬을 수행하는것보다 부분 집합으로 나누어 정렬하면, 비교연산과 교환연산의 횟수를 줄일 수 있다.  
셸 정렬에서 부분 집합을 만드는 기준이 되는 간격을 매개변수 h에 저장한다. 한 단계가 수행될 때마다 h의 값을 감소시키고, 셸정렬을 순환호출하는데, 결국 h가 1이 될때까지 반복한다. 셸정렬의 성능은 매개변수 h의 값에 따라 달라진다. 일반적으로 사용하는 h의 값은 원소 개수의 1/2을 사용하고(맨 처음에는 원소갯수의 1/2개의 부분집합이 발생한다), 한단계 수행될때마다 h의 값을 반으로 감소시키면서 h가 1이 될때까지 반복 수행한다.

7) 병합 정렬(Merge Sort)
--- 
병합정렬은 여러개의 정렬된 자료의 집합을 결합하여 한 개의 정렬된 집합으로 만드는 방법이다. 병합 정렬은 전체 원소들에 대해서 수행하지 않고, 부분집합으로 분할(divide)하고, 각 부분집합에 대해서 정렬 작업을 완성(conquer)한 후에 정렬된 부분집합들을 다시 결합(combine)??(이때, 정렬방법은?)하는 분할 정복(Divide and Conquer)기법을 사용한다.  
- 2개의 정렬된 자료의 집합을 결합하여 하나의 집합으로 만드는 병합방법을 2-way병합이라한다.  
- n개의 정렬된 자료의 집합을 결합하여 하나의 집합으로 만드는 병합방법을 n-way병합이라고 한다.   

2-way 병합 정렬은 다음과 같은 작업을 반복수행한다.  
1. 분할(divide) : 입력자료를 같은 크기의 부분집합 2개로 분할한다.(정렬한 전체 자료의 집합에 대해서 최소 원소의 부분 집합이 될때까지 분할 작업을 반복하여 1개의 원소를 가진 부분집합 n개를 만든다.) 
2. 병하단계 :  2개의 부분집합을 정렬하면서 하나의 집합으로 병합한다. n개의 부분집합이 1개로 병합될때까지 반복한다. 
    - 정복(conquer) : 부분집합의 원소들을 정렬한다 부분집합의 크기가 층분히 작지 않으면 순활 호출?을 이용하여 다시 분할 정복 기법을 적용한다.   
    - 결합(combine) : 정렬된 부분집합들을 하나의 집합으로 통합한다.

8) 기수 정렬(Radix Sort)
--- 
분배 방식의 정렬 방법으로 정렬할 원소의 키값에 해당하는 버킷(bucket)에 원소를 분배하였다가 버킷의 순서대로 원소를 꺼내는 방법을 반복한다 기수 정렬은 원소의 키를 표현하는 값의 기수(Radix)만큼의 버킷이 필요하고, 키값의 자릿수만큼  기수정렬을 반복한다. 10진수로 표현된 키값을 가진  원소들을 정렬할 때에는 0부터 9까지 10개의 버킷을 사용한다. 먼저 키값의 일의 자리에 대해서 기수정렬을 수행하고, 다음단계에서는 키값의 십의자리에 대해서, 그 다음에는 백의 자레에 대해서 기수정렬을 수행한다.즉, 최댓자릿수가 두자리이면 기수정렬은 두번 반복한다. 한단계가 끝날때마다 버킷에 분배된 원소들을 버킷의 순서대로 꺼내서 다음단계의 기수정렬을 수행해야 하므로 큐를 사용하여 버킷을 만든다.   
초기상태 : 큐를 사용하여 0부터 9까지 10개의 버킷을 만든다.  
1. 키값의 일의 자리에 대해서만 기수 정렬을 수행한다.(2와 12,22는 같은 버킷2에 분배된다.)  
2. 버킷에 분배된 원소들은 순서대로 꺼내서 다시 저장한다  
3. 키값의 십의 자리에 대해서만 기수정렬을 수행한다. (23과 29은 같은 버킷 2에 분배된다.)  
4. 버킷에 분배된 원소들을 순서대로 꺼내어 다시 저장하면 두번의 기수정렬만으로 전체 원소에 대한 정렬을 완성한다.

9) 힙 정렬(Heap Sort)
--- 
힙정렬은 힙 자료구조를 이용하여 정렬하는 방법이다. 힙에서는 항상 가장 큰 원소가 루트노드가 되고, 삭제연산을 수행하면 항상 루트노드의 원소를 삭제하여 반환하는 특성이 있다.그러므로 최대 힙에 대해서 원소의 갯수만큼 삭제연산을 수행하면 내림차순으로 정렬된 원소를 얻을 수 있고, 최소 힙에 대해서 원소의 개수만큼 삭제연산을 수행하면 오름차순으로 정렬된 원소를 얻을 수 있다. 힙 정렬은 정렬할 원소들을 입력하여 최대 힙을 구성한다.  그리고 힙에 대해서 삭제연산을 수행하여 얻은 원소를 마지막 자리에 배치하고, 힙을 다시 최대 힙이 되도록 재구성?하는 작업을 원소의 갯수만큼 반복하면 오름차순의 정렬을 완성할 수 있다?  
초기상태 : 정렬할 원소가 n개이므로 노드가 n개인 완전 이진 트리를 만들고 최대 힙으로 구성한다.  
1. 힙에 삭제 연산을 수행하여 루트노드의 값을 구해서 배열의 마지막 자리에 저장하고 나머지 원소들에 대해서 최대 힙으로 구성한다. 이러한 과정을 반복하여, 공백 힙이 되면 힙정렬을 종료한다.

10) 트리 정렬(Tree Sort)
--- 
트리 정렬은 이진 탐색트리를 이용하여 정렬하는 방법이다. 정렬할 원소들을 이진 캄색 트리로 구성하고 중위 순회 방법을 사용하여, 이진 탐색 트리의 원소들을 순회하여 꺼내면, 오름차순 정렬이 된다.  
1. 정렬할 원소 n개를 차례대로 트리에 삽입하여 이진 탐색트리를 구성한다.  
2. 이진탐색트리를 중위 순회 방법으로 순회하면서 원소를 저장한다.

5.검색
===
저장한 자료를 그 자료를 구별하여 인식할 수 있는 키를 가지고 있는데 이를 탐색키(Search Key)라고 한다. 자료를 검색하는 것은 원하는 탐색키를 가진 항목을 찾는 것이다.   
검색연산은 삽입연산과 삭제 연산을 위해서는 그 위치를 찾아야하는데, 수행된다. 검색방법의 효율성은 어떠한 자료구조의 형태를 사용하고 있는지와 자료의 배열 상태에 따라 영향을 받으므로 문제에 맞는 가장 적당한 검색방법을 선택하여 수행하여야한다.   
검색이 수행되는 위치에 따라 메모리 내의 자료에 대해서 수행하는 내부 검색(Internal Search)와 메모리의 외부에 있는 보조 기억장치에 있는 자료에 대해서 수행하는 외부검색(External Search)이 있다.  
검색 방법에 따라서는 
- 비교검색방식(Comparison Search Method) : 검색 대상의 키를 비교하여 검색하는 방법(순차검색, 이진 검색, 트리 검색)   
- 계산검색방식(Non-comparison Method) : 계수적인 성질을 이용한 계산으로 검색하는 방법(해싱)   

1) 순차검색
---  
순차검색은 가장 쉽고 단순한 검색방법으로서 순서대로 항목을 비교하면서 검색하는 순차 검색과 인덱스 테이블을 사용하여 검색의 효율을 높인 색인 순차 검색이 있다.  

(1) 순차검색(Sequential Search)  
순차검색은 일렬로 되어있는 자료를 처음부터 마지막까지 순서대로 검색하는 방법으로 선형검색(Linear Search)이라고도 한다. 순차검색은 가장 간단하고 직접적인 방법으로서 배열이나 연결리스트로 구현된 순차 자료구조에서 원하는 항목을 찾는 방법이다. 순차 검색은 검색해야하는 자료의 양에 따라 효율이 달라지기 때문에 자료가 아주 많은 경우에는 비효율적이지만, 알고리즘이 단순하여 구현이 쉬운 장점이 있다.  
#### 정렬되지 않은 순차 자료구조에서의 순차검색
첫 번재 원소부터 시작하여 마지막 원소까지 순서대로 키값이 일치하는 원소가 있는지를 비교하여 찾는다. 키값이 일치하는 원소를 찾으면 그 원소가 몇 번째 원소인지를 반환한다. 마지막 원소까지 비교하여 일치하는 원소가 없으면 검색실패가 된다.
#### 정렬되어 있는 순차 자료구조에서의 순차검색
정렬되어 있지 않은 자료에서 순차 검색을 하는 경우에 검색 실패는 마지막 원소까지 모두 비교한 후에야 알 수 있다는 단점이 있다. 하지만, 정렬되어 있는 경우, 원소의 키값이 찾는 키값보다 크면 원소가 없는 것이므로 더이상 검색을 수행하지 않고 끝낼 수 있다.

(2) 색인 순차 검색(Index Sequential Search)  
색인 순차검색은 인덱스 테이블(Index Table)을 추가로 사용하여 탐색의 효율을 높인 검색 방법이다. 인덱스 테이블은 배열에 정렬되어 있는 자료 중에서 일정한 간격으로 떨어져 있는 원소들을 가지고 있다. 자료가 저장되어 있는 배열의 크기가 n이고 인덱스 테이블의 크기가 m일 때, 배열에서 n/m간격으로 떨어져 있는 원소와 그의 인덱스를 인덱스 테이블에 저장한다. 찾고자 하는 키값을 인덱스 테이블에서 검색하여  indexTable[ i ].key <= key < indexTable[ i+1 ].key를 만족하는 i를 찾아서 뱅ㄹ의 어느 범위에 있는지를 먼저 알아낸 후에 해당 범위에 대해서만 순차 검색을 수행한다. 즉, 범위를 먼저 인덱스 테이블을 통해서 알아낸 후에 순차검색을 수행한다.   
색인 순차 테이블의 성능은 인덱스 테이블의 크기에 따라 달라진다. 인덱스 테이블의 크기가 줄어들면 배열의 인덱스를 저장하는 간격이 커지므로 범위도 커진다. 테이블의 크기를 늘리면, 배열의 인덱스를 저장하는 간격이 작아지므로 배열에서 검색해야하는 범위는 작아지지만, 인덱스 테이블을 검색하는 시간이 늘어나게 된다.

2) 이진 검색(Binary Search)
---  
이진 검색은 잘의 가운데에 있는 항목을 키값과 비교하여 키값이 더 크면 오른쪽 부분을 검색하고, 키값이 더 작으면, 왼쪽 부분을 검색하는 방법이다. 가운데 있는 값을 기준으로 왼쪽과 오른쪽의 두 부분으로 나누어서 검색하므로 이분검색 또는 보간검색(Interpolation Search)이라고도 한다. 키를 찾을때까지 이진 검색을 순환적으로 반복수행함으로써 검색범위를 반으로 줄여가면서 더 빠르게 검색한다. 또한, 검색 범위를 반으로 분할하고 검색을 수행하는 작업을 반복하므로 분할 정복 기법이라고도 한다.  
기준값을 두고 검색범위를 두부분으로 나누고 다시 나눈 상태에서 또 기준값을 두고 검색범위를 나누어서 반복 수행한다.  어느 부분으로 갈지는 기준값을 비교해서 결정한다. 검색범위를 줄여 성능은 좋지만, 삽입 혹은 삭제연산을 수행한 후에 항상 배열의 상태를 정렬된 상태로 유지해야하는 작업이 추가로 필요하다.

3) 이진 트리 검색(Binary Tree Search)
---  
이진 탐색트리 검색은 이진 탐색 트리를 사용하여 검색하는 방법이다. 이진 탐색 트리는 루트 노드를 기준으로, 왼쪽 서브 트리는 루트노드보다 키값이 작은 원소들로 구성하고, 오른쪽 서브트리는 루트노드보다 키값이 큰 원소들로 구성한 이진트리다. 이렇게 구성한 이진 탐색트리는 중위 순회방법으로 순회하면 오름차순올 정렬된 자료를 구성할 수 있다.  
이진 탐색트리 검색은 이진탐색트리의 특성을 이용하여 쉽게 검색할 수 있지만, 원소의 삽입이나 삭제 연산에 대해서 항상 이진 탐색트리를 재구성항 유지해야하는 단점이 있다.

4) 해싱 (Hashing)
--- 
해싱은 키값을 비교하여 찾는 검색 방법이 아니라, 산술적인 연산을 이용하여 키가 있는 위치를 계산하여 바로 찾아가는 계산 검색 방식이다. 키 값을 원소의 위치로 변환하는 함수를 해싱(Hashing)함수라고 하고, 해싱함수에 의해 계산된 주소의 위치에 항목을 저장한 표를 해시 테이블(Hash Table)이라고 한다.  

- 해싱 검색 방법  
해싱 검색은 키 값에 대해서 해싱 함수를 계산하여 주소를 구하고, 구한 주소에 해당하는 해시테이블에 찾는 항목이 있으면, 검색이 성공이 되고, 없으면 검색 실패가 된다.   
해시 테이블은 n개의 버킷과 m개의 슬롯으로 구성한다. 해싱함수에 의해서 계산된 주소는 버킷 주소가 된다. 이때 사용하는 해싱함수는 0 ~ n-1 사이의 버킷주소을 만들어야 한다. 해싱함수에 의해서 알아낸 버킷에 키값이 저장된 슬롯이 여러개 있는 경우에는 순차 검색을 하여 해당 슬롯을 검색한다.

+1. HashTable

    (데이터 접근 구조)
    F(key) -> HashCode -> Index -> Value

장점 : 검색속도가 매우 빠름 왜냐하면, Hash함수를 통해 만든 HashCode가 정수이기때문에 배열공간 고정된 크기만큼 만들어 hash코드를 나누어서 배열에 나눠담는다. 즉, 해쉬코드 자체가 배열 인덱스로 작용하므로 direct로 배열에 접근하기에 빠름  
단점 : 이때, 해쉬코드를 배열에 나누어 담을때, 충돌(collison)현상을 막기위해 규칙을 잘 해야한다. 이를 Hash Algorithm이라고 한다. 너무 한군데에 몰려있으면 한 곳만 비교해도 모두 비교하는 거와 마찬가지가 되고, O(N)의 시간이 걸린다. 즉, 얼마나 잘 골고루 분배했느냐가 중요하다.

+2. ArrayList

Java의 경우 Array로 객체를 생성하면, 배열의 크기가 fixed된다. 그러나 ArrayList의 경우 크기가 유동적이다. 하지만 검색 시간은 O(1)의 시간이 걸린다.  
왜나하면, ArrayList에 배열이 다 차면, 배열을 두배로 늘리는 작업(Doubling)을 한다. 그렇기에 검색할때는 어차피 고정된 크기에서 검색을 한다.  
Doubling하는데 걸리는 시간은 원래 배열의 크기 n이면 o(n)의 시간이 소요된다. 그러나, 이러한 번거로운 과정에도 불구하고, 입력시간은 O(1)의 시간이 걸린다.  
왜냐하면, 더블링할때, 그전의 더블링은 n/2 시간 그전은 n/4시간이 걸림 모두더하면, n 이상의 시간이 걸리지않으므로 한번 검색하는 1이상의 시간은 걸리지 않음?

+3 StringBuilder





















