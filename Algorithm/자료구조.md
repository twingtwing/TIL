자료구조
===

1.1 자료구조란?
===

    데이터 표현 및 저장방식
    다양한 자료를 효율적으로 표현해 저장하고 처리하여 사용할 수 있도록 하는것  


1.2 왜 자료구조를 사용하는가?
===
    컴퓨터의 동작성능은 명령을 내려주는 사람에 따라 달라지기 때문이다.

    표현하고자 하는 자료의 특성과 양, 자료의 주된 사용 방법과 수행하는 연산의 종류, 구현에 필요한 기억공간 용량을 고려하여 가장 효율적인 자료구조를 선택하면, 컴퓨터의 동작 성능은 월등히 올라가게 된다. 그렇기 때문에 우리는 자료구조를 공부해야하고 알고리즘을 공부해야한다.

    문제 해결을 위해 추상적으로 정의한 데이터와 연산자를 구체적으로 구현하여 실행해야 하는데, 연산자의 구현은 데이터를 표현하는 방법에 의해 결정된다. 따라서 처리할 문제에 대한 데이터를 가장 효율적인 방법으로 표현하는것이 중요하므로, 자료구조에 대해 공부해야하낟.

1.3.자료구조 형태에 따른 분류
===
- **단순 구조** : 정수, 실수, 문자, 문자열 등의 데이터 타입
- **선형 구조** : 자료 간에 일대일의 관계를 가지고 구조
- **비선형 구조** : 자료 간에 1:n or n:n 관계를 가지는 구조
- **파일 구조**

2.자료구조의 데이터를 구조화 시키는 기본표현방식
===
2.1 순차 자료구조 방식
---
리스트에서 나열한 원소들간에 순서를 가지고 있는 리스트를 선형리스트 또는 순서 리스트라 한다. 이러한 리스트는 원소들간에 논리적인 순서와 메모리에 저장하는 물리적인 순서가 같은 구조로 되어있는데, 이러한 구조를 **순차 자료구조**라고 한다.   
   
[ 장점 ]
- 순차 자료구조에서는 원소의 논리적인 순서대로 데이터가 메모리에 저장되기 때문에, 시작위치와 원소의 길이를 알면 특정 원소의 위치를 알 수 있다.
- 그렇기대문에 원소들의 순서를 따로 표시할 필요가 없이 간단히 구성할 수가 있고, 인덱스를 사용하여 특정 원소를 쉽게 엑세스할 수 있다.

[ 단점 ]
- 물리적인 순서대로 연속하여 저장되기 때문에, 원소 삽입혹은 삭제가 발생할 경우 발생한 원소 이후에 있는 원소들은 한자리씩 뒤로 이동하거나 앞으로 이동해야한다.(원소들의 이동작업 필요)  
    => 순차자료구조는 논리적인순서와 물리적인순서가 같은순서대로 연속적으로 저장되기때문에 중간에 빈자리가 있어서는 안되기 때문
- 원소를 삽입하거나 삭제할 경우에 물리적으로 원소들을 뒤로 밀어내거나 앞으로 당겨서 순서를 유지해야     하기 때문에 원소이동작업으로 추가적인 오버헤드가 많이 발생하여 성능상의 문제를 일으킬 수 있다.    
- 순차 자료구조 방식은 배열을 이용하여 구현하기 때문 배열이 갖고 있는 메모리 사용의 비효율성 문제를 그대로 갖는다.
##

    순차 자료구조는 삽입/삭제 연산이 많이 필요한 문제에서 순차 자료구존를 사용하는 것은 비효율적이다.


2.2 연결 자료구조 방식 (=비순차 자료구조 방식)
---
순차 자료구조방식에서의 연산시간에 대한 문제와 저장공간에 대한 문제를 개선한 자료구조 표현방식
- 연결자료 방식은 순차와 달리 논리적인 순서와 물리적인 순서가 일치할 필요가 없다.
- 연속한 메모리 물리주소에 의해 원소의 순서를 표현하는 것이 아니라, 각 원소에 저장되어 있는 다음 원소의 주소에 대한 참조에 의해서 연결되는 방식이기대문에, 물리적인 순서를 맞추기 위한 오버헤드가 발생하지 않는다.
- 하나의 순차 자료구조를 위해서는 하나의 고정크기 메모리 공간을 사용하지만, 연결 자료구조에서는 여러개의 작은공간을 연결하여 전체를 표현하기 때문에 크기변경이 유연하고 좀더 효율적으로 메모리를 사용할 수 있다. => 중요한거 같음 더 공부 필요
##
    [ 노드 ]
    연결 자료구조 방식에서 원소는 연결될 다음 원소에 대한 주소를 저장해야 하기 때문에 <원소,주소>의 단위로 저장해야 한다. 이러한 단위구조를 노드(node)라고 한다.  
      
    노드는 [data][link]에서와 같이 원소의 값을 저장하는 데이터 필드와 다음 노드의 주소를 저장하는 링크 필드로 구성된다.   
    데이터필드 : 저장할 원소의 형태에 따라서 하나 이상의 필드로 구성하기도 한다. 
    링크필드 : 메모리 참조 변수를 사용하여 주소에 대한 참조값을 저장하며, 링크 또는 참조라고 한다.  

    참조값(링크값)(리스트 이름) [첫번째 노드의 주소 참조값] => 리스트 이름은 첫번째 노드에 대한 참조를 나타내지만, 첫번째 노드에 연결된 리스트 전체를 의미??  
    리스트 이름은 연결리스트의 시작 위치를 가리키는 메모리 참조변수이기도 하다
    첫번째 참조값[첫번째 데이터 필드 : 두번쩨 노드의 주소] =>다음에 연결할 노드의 주소에 대한 참조값을 저장하고 잇음
    두번째 참조값[마디막 데이터 필드 : null] => 더이상 연결할 노드가 없기 때문에 링크필드에 null을 저장한다.  
    만약  노드가 하나도 없는 공백 연결 리스트일 경우 참조변수(리스트 이름)에  null을 저장한다.  

    각 노드 필드에 저장한 값은 참조변수의 점 연산자를 사용하여 엑세스한다.   
    week.data는 참조변수 week가 가리키는 첫번째 노드필드의 데이터필드값이 된다.
    week.link는 참조변수 week가 가리키는 첫번째 노드필드의 링크필드값이 된다.
    week.link.data는 참조변수 week가 가리키는 노드필드의 링크필드가 가리키는 데이터 필드값이 된다. 즉, 두번째 노드의 데이터 필드값이 된다.
##

    장점
    - 연결 구조는 링크필드에 대한 저장공간이 추가로 필요하지만, 순차구조에서 물리적 순서를 맞추기 위해 필요한 오버헤드가 없기때문에 연결 구조를 더 많이 사용한다.'
    - 링크필드의 참조값에 대한 연산만으로 쉽게 삽입/삭제연산을 수행할 수 있다.
    - 순차 선형리스트와는 달리 원소이동현상이 일어나지 않는다.
    
### 1) 단순 연결 리스트(=연결리스트=선형연결리스트=단순연결선형리스트)
노드가 하나의 링크 필드에 의해서 다음 노드와 연결되는 구조를 가진 연결 리스트다.
#### (1) 단순 연결 리스트의 노드 삽입 / 삭제 연산
- 삽입연산일 경우, 앞의 노드는 삽입할 노드의 참조값을 저장하고 삽입할 노드는 다음 노드의 참조값을 저장한다.
- 삭제연산일 경우, 앞의 노드에 삭제할 노드의 참조값으로 덮어씌운다. 이때 삭제할 노드는 여전히 다음노드의 참조값을 저장하고 있지만, 삭제할 노드를 연결하는 앞의 노드가 삭제할노드를 가르키지 않기때문에 굳이 삭제할 노드에  null을 저장할 수고를 줄일 수 있다. 이미 의미없는 값이 되었기 때문이다.
- 순차 선형리스트와 달리 단순 연결 리스트의 삽입 연산에서는 물리적 순서를 유지하기 위해서 원소이동현상이 일어나지 않는다.
#### (2) 자유공간리스트
연결 리스트에서 삽입연산을 하려면 먼저 메모리에서 공백노드를 가져와야하고, 삭제연산에서는 삭제되어 사용하지않는 노드에 대한 메모리공간을 처리해야 한다. 즉, 삽입/삭제 연산시에 메모리할당작업이 필요하다.  
이러한 작업을 사용하지 않은 메모리 공간이 미리 노드의 구조로 나누어져 연결리스트로 만들어져 노드를 할당하거나 혹은 반환받을 수 있다면, 연산과정과 메모리 관리가 효율적으로 이루어질 수 있다.  
이렇게 메모리를 사용하기 전에 미리 노드를 나누어서 연결해 놓은 리스트를 자유공간리스트(Free Space List)라고 한다.