# Sort
    ✍️ 순서없이 배열되어 있는 자료들을 오름차순(ascending) 혹은 내림차순(descending)으로 재배열
## 1. 정렬 방법의 분류

### 1.1 실행 방법에 따른 분류 
정렬은 실행하는 방법에 따라 비교식 정렬(Comparative Sort)과 분산식 정렬(Distribute Sort)로 구분할 수 있다. 
- 비교식 정렬 : 비교하고자 하는 각 키 값들을 한 번에 두 개씩 비교하여 교환하는 방식으로 정렬을 실행한다.  
- 분산식 정렬 : 키 값을 기준으로 하여 자료를 여러 개의 부분집합으로 분해하고, 각 부분집합을 정렬함으로써 전체를 정렬하는 방식으로 실행한다. 

### 1.2 정렬 장소에 따른 분류   
컴퓨터에서 수행되는 정렬은 컴퓨터 메모리 내부에서 정렬하는 내부정렬(Internal Sort)과 메모리의 외부인 보조 기억 장치에서 정렬하는 외부정렬(External Sort)로 분류할 수 있다.
- 내부정렬 : 내부 정렬은 정렬할 자료를 메인 메모리에 올려서 정렬하는 방식으로 정렬 속도가 빠르지만, 정렬할 수 있는 자료의 양이 메인 메모리의 용량에 따라 제한된다.   
    (내부 정렬을 사용하는 정렬방식)
    1. 교환방식 : 키를 비교하고, 교환하여 정렬하는 방식 (선택 정렬, 버블 정렬, 퀵 정렬)
    2. 삽입방식 : 키를 비교하고 삽입하여 정렬하는 방식 (삽입정렬, 셀 정렬)
    3. 병합방식 : 키를 비교하고, 병합하여 정렬하는 방식 (2-way 병합, n-way 병합)
    4. 분배방식 : 키를 구성하는 값을 여러 개의 부분집합에 분배하여 정렬하는 방식 (기수 정렬)
    5. 선택방식 : 이진 트리를 사용하여 정렬하는 방식 (힙 정렬, 트리 정렬)
- 외부 정렬 : 외부정렬은 대용량의 보조 기억 장치를 사용하기 때문에 내부 정렬보다 속도는 떨어지지만, 내부 정렬로 처리할 수 없는 대용량의 자료를 정렬 처리할 수 있다.  
    - 병합방식 : 파일을 부분 파일로 분리한 후 각각을 내부 정렬 방법으로 정렬하여 병합하는 정렬방식 (2-way 병합, n-way 병합)

## 2. Sort의 종류
    ❗정렬방법의 효율성을 비교하는 일반적인 기준은 원소에 대한 비교횟수와 이동횟수가 된다. 
### 2.1 Selection Sort
선택정렬은 전체 원소들 중에서 기준 위치에 맞는 원소를 선택하여 자리를 교환하는 방식으로 정렬한다. 전체 원소중에서 가장 작은 원소를 찾아서 선택하고  첫번째 원소와 자리를 교환한다. 그 다음 두 번째로 작은 원소를 찾아 선택하여 두번째 원소와 자리를 교환하고, 차례대로 교환하는 과정을 마지막까지 반복하면서 선택 정렬을 완성한다.

<details>
<summary>Selection Sort 알고리즘</summary>

```java
```
</details>    
<br>

### 2.2 Bubble Sort
버블 정렬은 인접한 두개의 원소를 비교하여 자리를 교환하는 방식으로, 첫번째 원소부터 마지막 원소까지 반복하면 가장 큰 원소가 마지막자리로 정렬하게 된다. 마지막을 제외한 나머지 원소 중에서 이러한 과정을 반복하고, 나머지 원소가 없어지면 버블정렬을 완성한다. 첫번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서, 맨 마지막 자리로 이동하는 모습이 물방울 모양과 같다고해서 버블 정렬이라고 한다.

<details>
<summary>Bubble Sort 알고리즘</summary>

```java
```
</details>    
<br>

### 2.3 Quick Sort
퀵정렬은 정렬할 전체 원소에 대해서 정렬을 수행하지 않는다. 먼저 기준값을 중심으로 전체 원소들을 왼쪽 부분집합과 오른쪽 부분집합으로 분할(divide)한다. 왼쪽 부분집합에는 기준값보다 작은 원소들을 이동시키고, 오른쪽 집합에는 기준값보다 큰 원소들을 이동시킨다. 이때 사용하는 기준값을 피봇(pivot)이라고 하는데, 일반적으로 전체 원소중에서 가운데에위치한 원소를 피봇으로 선택한다. 
퀵정렬은 다음의 두 가지 기본작업을 반복 수행하여 완성한다.   
    1. 분할(divide) : 정렬할 자료들을 기준값을 중심으로 2개의 부분집합으로 분할한다.  
    2. 정복(conquer) : 부분집합의 원소들 중에서 기준값보다 작은 원소들은 왼쪽 부분집합으로, 기준값보다 큰 원소들은 오른쪽 부분집합으로 정렬한다. 부분집합의 크기가 1 이하로 층분히 작지 않으면 순환호출?을 이용하여 다시 분할한다.  
분할 작업을 순환적으로 반복하면서 피봇의 왼쪽 부분집합과 오른쪽 부분집합을 정렬하는 방법을 반복하면서 전체 원소들을 정렬한다. 부분집합으로 분할하기 위해서 L과 R을 사용한다. 왼쪽 끝에서 오른쪽으로 움직이면서 크기를 비교하여 피봇보다 크거나 같은 원소를 찾아 L로 표시하고, 오른쪽 끝에서 왼쪽으로 움직이면서  피봇보다 작은 원소를 찾아 R로 표시한 후에 두 원소를 서로 교환한다. L과 R이 만나면 피봇과 R의원소를 서로 교환하고 피봇의 위치를 확정한다. 만나지 않으면, L과 R을 서로 교환하고, 피봇의 위치를 확정한다. 피봇의 확정된 위치를 기준으로 만들어진 왼쪽 부분집합과 오른쪽 부분집합에 대해서 퀵정렬을 순환적으로 반복수행하고, 부분집합의 크기가 1 이하가 되면 퀵정렬을 종료한다.   
퀵정렬은 버블정렬은 인접한 두개의 원소를 비교하여 자리를 교환하기 때문에 원소가 이동하는 거리가 1이되어 자기 자리를 찾기까지 비교횟수와 자리교환횟수가 많음점을 개선하여 자기자리에 최대한 가까이 이동시켜서 비교횟수와 자리교환횟수를 줄인 정렬 방법이다.

### 2.4 삽입 정렬(Insert Sort)
삽입 정렬은 정렬되어 있는 부분 집합에 정렬할 새로운 원소의 위치를 찾아 삽입하는 방법이다. 정렬할 자료가 두 개의 부분집합 S(Sorted)와  U(Unsorted)로 나뉘어 있다고 생각한다. 앞부분 원소부터 정렬을 수행하면서,  정렬된 앞부분의 원소들은 부분 집합 S가 되고,  아직 정렬되지 않은 나머지 원소들은 부분 집합 U가 된다. 정렬되지 않은 부분집합 U의 원소를 하나씩 꺼내어 이미 정렬되어 있는 부분집합 S의 마지막 원소부터 비교하면서 위치를 찾아 삽입하여 부분집합 S의 원소는 하나씩 늘리고 부분 집합 U의 원소는 하나씩 줄인다. U의 원소를 모두 삽입하여 공집합이 되면 삽입 정렬이 완성된다.  
초기상태 : 첫 번째 원소는 정렬되어 있는 부분집합 S로 생각하고, 나머지 원소들은 정렬되지 않은 원소들의 부분집합 U로 생각한다. 
1. U의 첫번째 원소를 S의 마지막 원소와 비교하여 S집합에 정렬하여 삽입한다.   
2. U의 첫번째 원소을 S의 마지막 원소와 비교하고, 마지막보다 크다면, 뒤에 두어 정렬을 마치지만, 만약 작다면 S의 그 전 순서인 원소와 비교하여 삽입한다.  
3. 해당 과정을 U가 공집합이 될때까지 반복한다. 

### 2.5 셸 정렬(Shell Sort)
셸 정렬(Shell Sort)은 일정한 간격(interval)으로 떨어져 있는 자료들끼리 부분 집합을 구성하고, 각 부분집합에 있는 원소들에 대해서 삽입 정렬??을 수행하는 작업을 반복하면서 전체 원소들을 정렬하는 방법이다. 전체 원소에 대해서 삽입 정렬을 수행하는것보다 부분 집합으로 나누어 정렬하면, 비교연산과 교환연산의 횟수를 줄일 수 있다.  
셸 정렬에서 부분 집합을 만드는 기준이 되는 간격을 매개변수 h에 저장한다. 한 단계가 수행될 때마다 h의 값을 감소시키고, 셸정렬을 순환호출하는데, 결국 h가 1이 될때까지 반복한다. 셸정렬의 성능은 매개변수 h의 값에 따라 달라진다. 일반적으로 사용하는 h의 값은 원소 개수의 1/2을 사용하고(맨 처음에는 원소갯수의 1/2개의 부분집합이 발생한다), 한단계 수행될때마다 h의 값을 반으로 감소시키면서 h가 1이 될때까지 반복 수행한다.

### 2.6 병합 정렬(Merge Sort)
병합정렬은 여러개의 정렬된 자료의 집합을 결합하여 한 개의 정렬된 집합으로 만드는 방법이다. 병합 정렬은 전체 원소들에 대해서 수행하지 않고, 부분집합으로 분할(divide)하고, 각 부분집합에 대해서 정렬 작업을 완성(conquer)한 후에 정렬된 부분집합들을 다시 결합(combine)??(이때, 정렬방법은?)하는 분할 정복(Divide and Conquer)기법을 사용한다.  
- 2개의 정렬된 자료의 집합을 결합하여 하나의 집합으로 만드는 병합방법을 2-way병합이라한다.  
- n개의 정렬된 자료의 집합을 결합하여 하나의 집합으로 만드는 병합방법을 n-way병합이라고 한다.   

2-way 병합 정렬은 다음과 같은 작업을 반복수행한다.  
1. 분할(divide) : 입력자료를 같은 크기의 부분집합 2개로 분할한다.(정렬한 전체 자료의 집합에 대해서 최소 원소의 부분 집합이 될때까지 분할 작업을 반복하여 1개의 원소를 가진 부분집합 n개를 만든다.) 
2. 병하단계 :  2개의 부분집합을 정렬하면서 하나의 집합으로 병합한다. n개의 부분집합이 1개로 병합될때까지 반복한다. 
    - 정복(conquer) : 부분집합의 원소들을 정렬한다 부분집합의 크기가 층분히 작지 않으면 순활 호출?을 이용하여 다시 분할 정복 기법을 적용한다.   
    - 결합(combine) : 정렬된 부분집합들을 하나의 집합으로 통합한다.

### 2.7 기수 정렬(Radix Sort)
분배 방식의 정렬 방법으로 정렬할 원소의 키값에 해당하는 버킷(bucket)에 원소를 분배하였다가 버킷의 순서대로 원소를 꺼내는 방법을 반복한다 기수 정렬은 원소의 키를 표현하는 값의 기수(Radix)만큼의 버킷이 필요하고, 키값의 자릿수만큼  기수정렬을 반복한다. 10진수로 표현된 키값을 가진  원소들을 정렬할 때에는 0부터 9까지 10개의 버킷을 사용한다. 먼저 키값의 일의 자리에 대해서 기수정렬을 수행하고, 다음단계에서는 키값의 십의자리에 대해서, 그 다음에는 백의 자레에 대해서 기수정렬을 수행한다.즉, 최댓자릿수가 두자리이면 기수정렬은 두번 반복한다. 한단계가 끝날때마다 버킷에 분배된 원소들을 버킷의 순서대로 꺼내서 다음단계의 기수정렬을 수행해야 하므로 큐를 사용하여 버킷을 만든다.   
초기상태 : 큐를 사용하여 0부터 9까지 10개의 버킷을 만든다.  
1. 키값의 일의 자리에 대해서만 기수 정렬을 수행한다.(2와 12,22는 같은 버킷2에 분배된다.)  
2. 버킷에 분배된 원소들은 순서대로 꺼내서 다시 저장한다  
3. 키값의 십의 자리에 대해서만 기수정렬을 수행한다. (23과 29은 같은 버킷 2에 분배된다.)  
4. 버킷에 분배된 원소들을 순서대로 꺼내어 다시 저장하면 두번의 기수정렬만으로 전체 원소에 대한 정렬을 완성한다.


### 2.8 힙 정렬(Heap Sort)
힙정렬은 힙 자료구조를 이용하여 정렬하는 방법이다. 힙에서는 항상 가장 큰 원소가 루트노드가 되고, 삭제연산을 수행하면 항상 루트노드의 원소를 삭제하여 반환하는 특성이 있다.그러므로 최대 힙에 대해서 원소의 갯수만큼 삭제연산을 수행하면 내림차순으로 정렬된 원소를 얻을 수 있고, 최소 힙에 대해서 원소의 개수만큼 삭제연산을 수행하면 오름차순으로 정렬된 원소를 얻을 수 있다. 힙 정렬은 정렬할 원소들을 입력하여 최대 힙을 구성한다.  그리고 힙에 대해서 삭제연산을 수행하여 얻은 원소를 마지막 자리에 배치하고, 힙을 다시 최대 힙이 되도록 재구성?하는 작업을 원소의 갯수만큼 반복하면 오름차순의 정렬을 완성할 수 있다?  
초기상태 : 정렬할 원소가 n개이므로 노드가 n개인 완전 이진 트리를 만들고 최대 힙으로 구성한다.  
1. 힙에 삭제 연산을 수행하여 루트노드의 값을 구해서 배열의 마지막 자리에 저장하고 나머지 원소들에 대해서 최대 힙으로 구성한다. 이러한 과정을 반복하여, 공백 힙이 되면 힙정렬을 종료한다.

### 2.9 트리 정렬(Tree Sort)
트리 정렬은 이진 탐색트리를 이용하여 정렬하는 방법이다. 정렬할 원소들을 이진 캄색 트리로 구성하고 중위 순회 방법을 사용하여, 이진 탐색 트리의 원소들을 순회하여 꺼내면, 오름차순 정렬이 된다.  
1. 정렬할 원소 n개를 차례대로 트리에 삽입하여 이진 탐색트리를 구성한다.  
2. 이진탐색트리를 중위 순회 방법으로 순회하면서 원소를 저장한다.

<br>

---

## Reference

- 자바로 배우는 자료구조 방식