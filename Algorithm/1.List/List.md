# List

    데이터를 구조화시키는 가장 기본적인 표현 방식으로 자료를 순서대로 나열하는 방식

## 1. 순차자료 구조 방식 : 선형 리스트(Linear List) 혹은 순차 리스트(Ordered List)
리스트에서 나열한 원소들간에 논리적인 순서와 메모리에 저장하는 물리적인 순서가 같은 구조를 **순차 자료 구조**라고 한다.

### 1.1 장점
- 원소의 논리적인 순서와 물리적인 순서가 같기 때문에, 시작위치와 원소의 위치를 알면,특정 원소의 위치를 알 수 있다.
- 원소들의 순서를 따로 표시할 필요가 없이 간단히 구성할 수 있다.
- index를 사용하여 특정 원소를 쉽게 접근 할 수 있다.

### 1.2 단점
- 순차자료구조는 논리적인 순서와 물리적인 순서가 같은 순서대로 연속적으로 저장되기 때문에 중간에 빈자리가 발생해서는 안된다.
- 원소 삽입/삭제가 발생한 원소 이후의 원소들은 한자리씩 앞/뒤로 이동해야한다. 즉, 원소들의 추가적인 이동 작업이 필요하다. 이러한 추가적인 원소이동작업은 추가적인 오버헤드를 많이 발생하여 성능상의 문제를 일으킬 수 있다.
- 순차 자료구조 방식은 배열을 이용하여 구현하기 때문에, 배열이 갖고 있는 메모리 사용의 비효율성 문제를 그대로 갖고 있다.???

    👉 순차 자료구조는 논리적인 순서와 물리적인 순서가 같기때문에, 특정 원소의 위치를 찾아 접근하기 쉽지만, 삽입/삭제 연산이 많이 필요한 문제에서는 순차 자료구조를 사용하는 것이 비효율적이다.


## 2. 연결 자료구조 방식(= 비순차 자료구조 방식) : Linked List

### 2.1 연결 자료구조 방식이란?
순차 자료구조 방식에서의 연산시간에 대한 문제(오버헤드?)와 저장공간에 대한 문젤르 개선한 자료구조 표현방식
- 연결자료 방식은 물리주소에 의해 원소의 순서를 표현하는 것이 아니라, 각 원소에 저장되어 있는 다음 원소의 주소에 대한 참조에 의해서 연결되는 방식이다. 그렇기에 논리적인 순서와 물리적이 순서를 일치시키기 위한 오버헤드가 발생하지 않는다.
- 순차자료구조는 배열을 사용하기 때문에, 고정크기 메모리 공간을 사용한다. 하지만, 연결 자료구조에서는 여러개의 작은 공간을 연결하여 전체를 표현하기 때문에 크기 변경이 유연하고 좀 더 효울적으로 메모리를 사용할 수 있다.

### 2.2 Node
연결 자료구조 방식에서 원소는 연결될 다음 원소 원소에 대한 주소를 저장해야하기 때문에 <원소,주소>의 단위로 저장해야 한다. 이러한 단위구조를 노드(node)라고 한다.

노드는 [data][link]에서와 같이 원소의 값을 저장하는 데이터 필드와 다음 노드의 주소를 저장하는 링크 필드로 구성된다.   
data field : 저장할 원소의 형태에 따라서 하나 이상의 필드로 구성하기도 한다.  
link field : 메모리 참보 변수를 사용하여 주소에 대한 참조값을 저장하며, 링크 또는 참조(reference)라고 한다.  

??? 그림으로 설명
참조값(링크값)(리스트 이름) [첫번째 노드의 주소 참조값] => 리스트 이름은 첫번째 노드에 대한 참조를 나타내지만, 첫번째 노드에 연결된 리스트 전체를 의미??  
    리스트 이름은 연결리스트의 시작 위치를 가리키는 메모리 참조변수이기도 하다
    첫번째 참조값[첫번째 데이터 필드 : 두번쩨 노드의 주소] =>다음에 연결할 노드의 주소에 대한 참조값을 저장하고 잇음
    두번째 참조값[마디막 데이터 필드 : null] => 더이상 연결할 노드가 없기 때문에 링크필드에 null을 저장한다.  
    만약  노드가 하나도 없는 공백 연결 리스트일 경우 참조변수(리스트 이름)에  null을 저장한다.  

    각 노드 필드에 저장한 값은 참조변수의 점 연산자를 사용하여 엑세스한다.   
    week.data는 참조변수 week가 가리키는 첫번째 노드필드의 데이터필드값이 된다.
    week.link는 참조변수 week가 가리키는 첫번째 노드필드의 링크필드값이 된다.
    week.link.data는 참조변수 week가 가리키는 노드필드의 링크필드가 가리키는 데이터 필드값이 된다. 즉, 두번째 노드의 데이터 필드값이 된다.
??? 그림으로 설명

### 2.3 장점 
- link field에 대한 저장공간이 추가로 필요하지만, 대신 순차 자료구조와는 달리 오버헤드가 없다.
- link field의 reference값에 대한 연산만으로 쉽게 삽입/삭제 연산을 수행할 수 있다.
- 선형 리스트와는 달리 원소이동현상이 일어나지 않기 때문에 오버헤드가 발생하지 않는다.


### 2.4 연결 자료구조 방식 종류

1) 단순 연결리스트 :  
하나의 Link field를 의해서 다음 노드와 연결하는 구조를 가진 연결 리스트
    - 삽입 연산 삽입연산일 경우, 앞의 노드는 삽입할 노드의 참조값을 저장하고 삽입할 노드는 다음 노드의 참조값을 저장한다.
    - 삭제 연산 삭제연산일 경우, 앞의 노드에 삭제할 노드의 참조값으로 덮어씌운다. 이때 삭제할 노드는 여전히 다음노드의 참조값을 저장하고 있지만, 삭제할 노드를 연결하는 앞의 노드가 삭제할노드를 가르키지 않기때문에 굳이 삭제할 노드에  null을 저장할 수고를 줄일 수 있다. 이미 의미없는 값이 되었기 때문이다.
그림 ;;
    - 단점 : 한 방향으로만 순회할 수 있는 구조이기때문에, 현재노드에서 이전 노드를 접근할려면 무조건 첫번째 노드에서 다시 시작해야한다.

2) 원형 연결리스트 :  
단순 연결 리스트에서 마지막 노드가 리스트의 첫번째 노드를 가리키게 하여 리스트의 구조를 원형으로 만든 연결리스트<br><br>
단순연결리스트와는 달리 이전 노드를 접근하기 위해 첫번째 노드부터 다시 시작할 필요가 없다. 원형으로 계속 순회하기 때문에 link를 따라 계속 순회하면, 이전 노드에 접근할 수 있다.
    - 삽입 연산 : 마지막 노드의 링크를 NULL로 두는 것이 아니라 첫번째 노드로 연결하는 부분만 제외하고는 단순 연결 리스트에서의 연산과 같다.
    - 삭제 연산: 마지막 노드 혹은 첫번째 노드 삭제시 다시 다음 마지막 노드 혹은 첫번째 노드와 연결해야하는 부분만 제외하고는 단순 연결 리스트에서의 연산과 같다.
그림 ;;
    - 단점 : 이전 노드에 접근은 가능하지만, 한 바퀴 순회를 해야하는 문제가 있다. 이는 link가 한방향으로만 되어 있기어서 반대방향으로 순회할 수 없기 때문에 발생한다.

3) 이중 (원형)연결 리스트 :  
link가 양방향으로 순회할 수 있도록 연결한 리스트를 이중 연결 리스트라고 한다.<br><br>
이중 연결리스트의 node는 [ 링크필드(llink/left filed) ][ 데이터필드 ][ 링크핑드(rlink/right filed  ) ] 두 개의 링크 필드와 한개의 데이터 필드로 구성된다.  
양쪽의 link field는 양쪽 노드를 참조하고 있기 때문에 양 방향으로 순회가 가능하다. 이때 첫번째 노드와 마지막 노드가 연결되어 있다면, 이중 원형 연결 리스트라고 한다.
    - 삽입 연산 삽입/삭제 연산 모두 원형 연결리스트와 같은 방법으로 진행되지만, 양쪽방향으로 모두 진행된다는것이 다른 점이다. 
    - 삭제 연산
그림 ;;

### 2.5 자유 공간 리스트
연결 리스트에서 삽입 연산을 할려면, 먼저 메모리에서 공백 노드를 가져와야하고, 삭제 연산에서는 삭제되어 사용하지 않는 노드에 대한 메모리공간을 처리해야 한다. 즉, 삽입/삭제 연산에는 메모리공간 할당 작업이 필요하다.<br><br>
이러한 작업을 일일이 처리하는 대신에 사용하지 않는 메모리 공간이 미리 노드의 구조로 나뉘어져 연결리스트로 만들어져 노드를 할당하거나 혹은 반환할 수 있다면, 연산과정과 메모리 관리가 효율적으로 이루어질 수 있다.

    메모리를 사용하기 전에 미리 노드를 나누어서 연결해 놓은 리스트를 자유 공간 리스트(Free Space List)라고 한다.

---

## Reference

- 자바로 배우는 자료구조 방식