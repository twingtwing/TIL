# Graph 
    ✍️ 
## 1. Graph란?
    Graph는 연결되어있는 원소간의 관계를 표현하는 자료구조이다.
그래프는 선형자료구조나 트리가 표현할 수 없는 모든 연결 구조들을 표현할 수 있기 때문에 여러분야에서 폭 넓게 사용할 수 있다.  
그래프는 연결할 객체를 나타내는 정점(vertax)과 객체를 연결하는 간선(edge)의 집합으로 구성된다. 그래프 G를  G=(V,E)로 정의하는데 V는 그래프에 있는 정점들의 집합을 의미하고, E는 정점을 연결하는 간선들의 집합을 의미한다.

### 1.1 Graph 용어
- 두 정점 a,b가 연결되어 간선(a,b)가 있을 때, 두 정점은 인접되어 있으며, 간선은 두 정점에 부속되어 있다고 한다.
- 방향 그래프에서 정점에 부속된 간선의 방향에 따라 정점을 꼬리로 하는 진입차수(in-degree)와 정점을 머리로 하는 진출차수(out-degree)가 있다. 방향 그래프에서 정점의 차수는 (진입차수 + 진출차수) 값이다. 
- 정점 a에서 b까지 간선으로 연결된 정점을 순서대로 나열한 리스트를 정점 a → b 까지의 경로(path)라고 한다. 이때 구성하는 간선의 수는 경로 길이가 된다. 
- 모든 경로는 단순 경로라고 하고, 시작정점과 마지막 정점이 같은 경로를 사이클이라 한다. 

## 2. Graph 종류
=> 그림으로 쉽게 표시
방향그래프는 cyclic(하나 이상의 사이클 있는 그래프) <-> Acyclic  

    그래프는 방향성과 연결 정도에 따라 여러 형태가 있다.
- Undirected Graph : 두정점을 연결하는 간선에 방향이 없는 Graph를 무방향그래프라고 한다. 정점 a와 정점 b을 연결하는 간선을 (a,b)로 표현한고, 방향이 없는 그래프이기에 (a,b)와 (b,a)는 같은 간선으로 취급한다. 무방향 그래프 G의 정점의 집합 V를 V(G) = { a,b }로, 간선의 집합을 E(G) =  { (a,b) }로 표현할 수 있다.
- Directed Graph : 간선에 방향이 있는 Graph를 다이그래프(digraph) 혹은 방향그래프라고 한다. 방향 그래프에서 간선은 a → b를 <a,b>라고 하며, a를 꼬리(tail), b를 머리(head)라고 한다. 방향 그래프에는 방향이 있기 때문에, <a,b>와 <b,a>는 서로 다른 간선으로 취급한다. 방향 그래프 G의 정점의 집합 V를 V(G) = { a,b }로, 간선의 집합을 E(G) = { <a,b>,<b,a> }로 표현할 수 있다.
  - 사이클이 없는 그래프를 DAG(Directed Acyclic Garph)라고 한다. 
- Complete Graph : 한 정점에서 다른 모든 정점을 연결되어 최대의 간선 수를 가지는 Graph를 완전 그래프라고 한다. 정점이 n개인 무방향 그래프의 최대 간선수는 (n(n-1))/2개 이며, 방향 그래프의 경우 n(n-1)개가 된다.
- subgraph : 원래 Graph에서 일부의 정점/간선을 제외하여 만든 Graph를 부분그래프라고 한다. 부분그래프g의 정점 집합과 간선집합은 원래그래프G의 정점 집합과 간선집합에 포함되는 관계를 가진다.
- weight graph : 정점을 연결하는 간선에 가중치를 할당하는 Graph를 가중 그래프 혹은 Network라고 한다.
- Path(경로) 유무에 따라 연결 그래프(Connected Graph) ⟷ 단절 그래프(Disconnected Graphh) 라고 한다.
## 3. Graph 구현
그래프를 구현하기 위해서는 정점에 대한 집합과 정점에 부속된 간선의 집합을 표현해야 한다. 그래프를 표현하는 방법은 순차 자료구조 방식을 이용하는 2차원 배열의 인접 행렬(Adjacent Matrix)방법과 연결 자료구조 방식인 연결리스트를 사용하는 인접 리스트(Adjacent List)방법이 있다.
Graph를 표현하는 방법에는 2가지가 있음  
- Adjacency Matrix : 2차원 배열에 나열하는 방법  
그래프를 표(2차원 배열)에 표현하는 방법. 즉, 연결되면 1로 표현하고, 아니면 0으로 표현한다.
- Adjacency List : 배열과 Linked List로 나열하는 방법  
배열방에 각각 Linked List가 존재하고, 해당 노드에 인접한 노드는 Linked List에 순서 상관없이 나열함 => 노드의 갯수가 n개이면, list의 총 노드는 2n개가 발생함   
### 3.1 순차 자료구조 방식을 이용한 그래프의 구현 : 인접행렬  
그래프를 구성하는 간선의 유무를 저장하는 방법으로 정점의 수에 대한 정방행렬을 사용한다. n개의 정점을 가진 그래프는 nXn 정뱅행렬을 사용하고, 두 정점이 인접하면 1 아니면 0으로 표현한다. 이런 방법으로 그래프를 표현한 행렬을 인접 행렬이라 한다.  
자기자신으로의 자체 간선은 있을 수 없으므로 대각선을 항상 0 값을 가진다. 무방향 그래프에서는 대각선을 중심으로 양쪽은 값이 항상 같기 때문에 대칭을 이룬다.   
방향그래프에서는 서로 다른 간선으로 취급하기 때문에, 대칭을 이루지 않는다. 행 i의 합은 정점 i의 진출차수가 되고, 열 i의 합은 정점 i의 진입차수가 된다.   
n개의 정점을 가지는 그래프를 nXn인접행렬로 표현하면, 간선의 개수에 상관없이 항상 nXn개의 메모리를 사용하기 때문에 메모리 낭비 문제가 발생한다.
### 3.2 연결 자료구조 방식을 이용한 그래프의 구현 : 인접 리스트  
각 정점에 대한 인접 정점들을 연결리스트로 만드는 것이다. 리스트의 각 노드는 정점을 저장하는 필드와 다음 인접 정점을 연결하는 링크 필드로 구성한다. 어떤 정점의 연결리스트는 그 정점에 인접한 정점의 수 만큼, 즉 그 정점의 차수만큼의 노드가 연결되어 있다. 리스트 내의 노드는 저장하는 정점에 대해서 오름차순으로 연결한다. 각 정점에 대한 참조변수를 배열로 구성하고, 각 정점에 대한 헤드 노드는 인접 정점의 노드 번호에 대한 오름차순으로 정렬하고 연결한 리스트를 가리킨다.  
n개의 정점과 e개의 간선을 가진 무방향 그래프에 대한 인접 리스트는 n개의 헤드노드 배열과 2e개의 노드가 필요하다. 방향그래프의 경우, 크기가 n인 헤드 노드배열이 필요하고, 각 헤드노드에 연결괴는 노드의 수는 각 정점 진출차수가 된다.

## 4. Graph 순회
하나의 정점에서 시작하여 그래프에 있는 모든 정점을 한번씩 방문하는 것을 그래프 순회 또는 그래프 탐색이라 한다. 

- [Depth - First - Search(DFS : 깊이 우선 방법)](Depth%20_First%20_Search.md) :  
  tree 검색 방법이었던 inorder,preorder,postorder들도 DFS에 속한다.  즉, child노드 이어가면서 leaf까지 가고 다시 올라가서 다시 아래로 내려가는 같은 방법으로 가능 방법이다.   
  Stack을 이용해 구현 : 시작 노드를 stack에 넣고, 시작노드를 출력할때, 자식노드들을 stack에 입력하고, 그중에 노드 한개를 출력할때 해당 노드의 자식 노드들을 입력함을 반복한다. stack이기 때문에 깊이 우선 방식이ㅏㄷ..응? 단, 한번 입력했던 노드는 다시 넣지 않는다.  
  재귀호출(Recursion)을 이용해 구현 : 시작노드를 호출하면, 자식노드를 호출하고 재귀호출이 계속 반복한다. 이때, 자식노드들을 호출할때, 정방향으로 우선적으로 호출한다. 또한, 자식노드들(a,b_) 중 정방향의 노드(a)를 우선 호출하여 해당 자식 노드들(b,c)을 호출하는데 여기에 형제 노드이면서 자식 노드인 (b)가 먼저 호출 되는것 이 아닌 어느 쪽부터 먼저 입력했는가를 우선적으로 호출???? 한다. 
- [Breadth - First - Search(BFS : 넓이 우선 방법)](Breadth%20_First%20_Search.md) : level단위로 형제노드들을 검색하는 방법  
  Queue를 이용해 구현 : 시작노드를 queue에 입력하고, 출력할때, 자식노드들을 queue에 입력하고, 반복한다. 여기서 후입선출이 아닌 선입선출이라는 점이 다르다. 이 점이, 넓이 우선 방식이다.엥????? DFS와 마찬가지로 한 번 넣었던 노드는 다시 입력하지 않는다. 
## 5. 신장트리와 최소 비용 신장 트리
트리는 사이클이 없는 연결 그래프이다.
사실 tree는 graph의 한종류이다.? tree는 graph에서 루트가 있고, 사이클이 없으며, 아래로만 흐르는 한방향이며, 들어오는 곳이 한개이다.? 그래프는 tree와는 달리 제약이 없다.  
그래프는 방향이 있을수도 없을수도 있다. tree는  Directed graph이다. 방향 그래프는 셀프엣지라고 자기자신을 가리키루도 있다.  

그래프에는 tree와는 달리 부모 자식 관계가 없다.

### 6.1 신장트리
그래프의 관점에서는 트리는 사이클이 없는 단순연결그래프이다. n개의정점으로 이루어진 무방향 그래프 G에서 n개의 모든 정점과 n-1개의 간선으로 만들어진 트리를 신장트리(Spanning)라고 한다.  
연결그래프에서 순회를 하면 n-1개의 간선을 이동하면서 모든 정점을 방문하게 되므로 신장트리를 생성하게 된다. 깊이 우선탐색을 이용하여 생성된 신장트리를 깊이 우선 신장(Depth First Spanning Tree)라 하고, 너비 우선 탐색을 이용하여 생성된 신장트리를 너비 우선 신장 트리(Bredth First Spanning Tree)라고 한다.  

### 6.2 최소 비용 신장트리
가중치 그래프에서 간선에 주어진 가중치는 비용이나 거리,시간을 의미하는 값이 될 수 있다. 따라서 무방향 가중치 그래프에서 신장트리의 비용은 신장트리를 구성하는 간선들의 가중치의 합이되는데, 가중치의 합이 최소인 신장트리를 최소 비용 신장 트리(Minimum Cost Spnning Tree)라고 한다. 최소 비용신장트리를 만들기 위해 kruskal이 만든 알고리즘과 prime이 만든 알고리즘을 주로 사용한다. 
    - Kruskal 알고리즘  
    해당 알고리즘은 가중치가 높은 간서을 제거하면서 최소 비용 신장트리르 만드는 Kruskal 알고리즘1과 가중치가 낮은 간선을 삽입하면서 최소 비용 신장트리를 만드는 Kruskal알고리즘2가 있다.  
        (1) Kruskal알고리즘1  
        ㄱ. 그래프 g의 모든 간선을 가중치에 따라 내림차순으로 정리한다.
        ㄴ. 그래프 g에서 가중치가 가장 높은 간선을 제거한다. (이때, 정점을 그래프에서 분리시키는 간선은 제거할 수 없다. 이런경우에는 그 다음 높은 간선을 제거한다.)  
        ㄷ. 그래프 g에 n-1개의 간선만 남을때까지 (2)를 반복한다.  
        ㄹ. 그래프에 n-1개의 간선이 남게 되면 최소 비용 신장트리가 완성된다.  
        (2) Kruskal알고리즘2
        ㄱ. 그래프 g의 모든 간선을 가중치에 따라 오름차순으로 정리한다.
        ㄴ. 그래프 g에서 가중치가 가장 작은 간선을 삽입한다.. (이때, 삽입하면 사이클을 형성시키는 간선은 삽입할수없고, 그 다음 작은 간선을 삽입한다.)  
        ㄷ. 그래프 g에 n-1개의 간선만 남을때까지 (2)를 반복한다.  
        ㄹ. 그래프에 n-1개의 간선이 남게 되면 최소 비용 신장트리가 완성된다.  
    - Prime 알고리즘  
    해당 알고리즘은 간선을 정렬하지 않고, 하나의 정점에서 시작하여 트리를 확장해 나가는 방법이다.  
        ㄱ. 그래프 g에서 시작 정점을 선택한다.  
        ㄴ. 선택한 정점에 부속된 간선중에서 가중치가 가장작은간선을 연결하여 트리를 확장한다.  
        ㄷ. 이전에 선택한 정점과 새로 확장한 정점에 부속된 모든 간선중에 가장 작은 간선을 삽입한다.(이때까지 선택한 정점과 확장한 정점(누적된 정점)중에서 부속된 간선들에서 고른다.) 이때 사이클을 형성하는 간선은 삽입할 수 없다. 이런 경우에는 다음 작은 간선을 삽입한다.  
        ㄹ. 그래프 g에 n-1개의 간선만 남을때까지 (2)를 반복한다.  
        ㅁ. 그래프에 n-1개의 간선이 남게 되면 최소 비용 신장트리가 완성된다.  

<br>

---

## Reference

- 자바로 배우는 자료구조 방식