# 🧷 SQL 파싱과 최적화

## 🖇️ SQL 이란?

> SQL : Structured Query Langauage

오라클 PL/SQL, SQL Server T-SQL처럼 절차적(Procedural) 프로그래밍 기능을 구현할 수 있는 확장 언어도 제공하지만, SQL은 기본적오르 구조적(Structured)이고 집합적(Set-Based)이고 선언적(Declarative)인 질의 언어다.  

원하는 결과집합을 구조적, 집합적으로 선언하지만, 그 결과 집합을 만드는 과정은 절차적일 수 밖에 없다. 즉, 프로시저가 필요한데, 그런 프로시저를 만들어 내는 DBMS 내부 엔진이 바로 `SQL 옵티마이저(Optimizer)`다. 옵티마이저가 프로그래밍을 대신하는 셈이다.

    사용자 -[SQL]→ 옵티마이저 -[실행계획]→ 프로시저

DBMS 내부에서 프로시저를 작성하고 컴파일해서 실행 가능한 상태로 만드는 전 과정을 `SQL 최적화`라고 한다.

## 🖇️ SQL 최적화
SQL을 실행하려면 SQL파싱과 SQL최적화 과정을 거친다.

### 1. SQL 파싱
사용자로부터 SQL을 전달받으면 가장 먼저 `SQL 파서(Parser)`가 파싱을 진행한다.
- 파싱 트리 생성 : SQL 문을 이루는 개별 구성요소를 분석해서 파싱 트리 생성. 
  
  ![SQL 파싱](https://drive.google.com/thumbnail?id=1LaBIwrsREiisAV7BTqa-yOLn0y83boUU&sz=w1000)

- Syntax 체크 : 문법적 오류가 없는지 확인
- Semantic 체크 : 의미상 오류가 없는지 확인 ex, 권한 부족, 공간 부족

### 2. SQL 최적화
- SQL 파싱 다음 단계이고, `옵티마이저가 처리`한다. 
- SQL 옵티마이저는 미리 수집한 시스템 및 오브젝트 통계정보를 바탕으로 다양한 실행경로를 생성해서 비교 후, 가장 효율적인 실행경로를 선택한다.
- 데이터 베이스 성능을 결정하는 가장 핵심적인 엔진이다.

### 3. 로우 소스 생성
SQL 옵티마이저가 선택한 실행경로를 실제 실행 가능한 코드 또는 프로시저 형태로 포맷팅하는 단계이다. `로우 소스 생성기(Row-Source Generator)가 처리`한다.

## 🖇️ SQL 옵티마이저
> **SQL 옵티마이저**는 가장 효율적으로 수행할 수 있는 최적화 액세스 경로를 선택해 주는 DBMS의 핵심 엔진이다.

1. 쿼리를 수행할 수 있는 실행 계획들을 찾아낸다.
2. 데이터 딕셔너리(Data Dictionary)에 미리 수집해 둔 오브젝트 통계 및 시스템 통계정보를 이용해 각 실행계획의 예상비용을 산정한다.
   - 데이터 딕셔너리는 데이터베이스 시스템 내부에 있는 메타데이터의 집합을 말하며, 데이터베이스의 구조, 정보 등에 관한 정보를 포함한다.
3. 최저 비용을 나타내는 실행계획을 선택한다.

## 🖇️ 실행계획과 비용
실행계획(Execution Plan)은 SQL 옵티마이저가 생성한 처리절차를 사용자가 확인할 수 있게 트리구조로 표현한 것이다. SQL이 테이블을 스캔하는지 인덱스를 스캔하는지, 어떤 인덱스인지를 확인할 수 있고, 예상과 다른 방식으로 처리된다면 실행경로를 변경할 수 있다.  

옵티마이저가 수많은 실행계획 중에서 최적의 실행계획을 찾는 근거는 비용(Cost)이다. **비용은 쿼리를 수행하는 동안 발생할 것으로 예상하는 I/O 횟수 또는 예상 소요시간을 표현한 값이다.** 
실행경로를 선택하기 위해 옵티마이저가 여러 통계정보를 활용해서 계산한 예상 값이기 때문에 실제 수행할 때 발생하는 I/O 또는 시간과 많은 차이가 난다.

## 🖇️ 옵티마이저 힌트
SQL 옵티마이저가 대부분 최적의 선택을 하지만, 항상 최선의 선택을 하는 것이 아니다. SQL이 복잡할수록 실수할 가능성도 크다. 옵티마이저 힌트를 이용해 액세스 경로를 바꿀 수 있다. 힌트 사용법은 `/*+ hint */` 와 `--+ hint`이 있다. 후자의 경우, 동적 쿼리 사용 시 줄바꿈 오류가 발생할 수 있기 때문에 가급적 사용을 자제하는게 좋다.

통계정보나 실행 환경 변화로 인해 옵티마이저가 가끔 실수하더라도 별문제가 없는 시스템이 있는 경우, 힌트를 적게 줘서 자율성을 준다. 옵티마이저의 작은 실수가 기업에 큰 손실을 끼치는 경우, 옵티마이저의 자율적 판단 대신 힌트를 빈틈없이 기술할 필요가 있다.

### 주의사항
- 힌트와 힌트 사이에 `,` 을 사용하면 안된다.
- 테이블지정할때 스키마 명까지 명시하면 안된다.
- FROM 절 테이블 명에 ALLAS를 지정했다면, 힌트에도 반드시 ALLAS를 사용해야 한다.

### 자주 사용하는 Hint

|분류|힌트|설명|
|:--:|--|--|
|최적화 목표|ALL_ROWS|전체 처리속도 최적화|
||FIRST_ROWS(N)|최초 N건 응답속도 최적화|
|액세스 방식|FULL|Tabl Full Scan으로 유도|
||INDEX|Index Scan으로 유도|
||INDEX_DESC|Index를 역순으로 스캔하도록 유도|
||INDEX_FFS|Index Fast Full Scan으로 유도|
||INDEX_SS|Index Skip Scan으로 유도|
|조인순서|ORDERED|FROM 절에 나열된 순서대로 조인|
||LEADING|LEADING 힌트 괄호에 순서대로 조인|
||SWAP_JOIN_INPUTS|해시 조인 시, BUILD INPUT을 명시적으로 선택|
|조인방식|USE_NL|NL 조인으로 유도|
||USE_MERGE|소트 머지 조인으로 유도|
||USE_HASH|해시 조인으로 유도|
||NL_SJ|NL 세미조인으로 유도|
||MERGE_SJ|소트 머지 세미조인으로 유도|
||HASH_SJ|해시 세미조인으로 유도|
|서브쿼리 팩토링|MATERIALIZE|WITH 문으로 정의한 집합을 물리적으로 생성하도록 유도|
||INLINE|WITH 문으로 정의한 집합을 물리적으로 생성하지 않고 INLINE 처리하도록 유도|
|쿼리 변환|MERGE|뷰 머징 유도|
||NO_MERGE|뷰 머징 방지|
||UNNEST|서브쿼리 Unnesting 유도|
||NO_UNNEST|서브쿼리 Unnesting 방지|
||   PUSH_PRED|조인조건 Pushdown 유도|
||NO_PUSH_PRED|조인조건 Pushdown 방지|
||USE_CONCAT|OR 또는 IN_List 조건을 OR-Expansion으로 유도|
||NO_EXPAND|OR 또는 IN_List 조건에 대한 OR-Expansion 방지|
|병렬 처리|PARALLEL|테이블 스캔 또는 DML을 병렬방식으로 처리하도록 유도|
||PARALLEL_INDEX|인덱스 스캔을 병렬방식으로 처리하도록 유도|
||PQ_DISTRIBUTE|병렬 수행 시 데이터 분배 방식 결정|
|기타|APPEND|Direct-Path Insert로 유도|
||DRIVING_SITE|DB Link Remote 쿼리에 대한 최적화 및 실행 주체 지정(Local 또는 Remote)|
||PUSH_SUBQ|서브쿼리를 가급적 빨리 필터링하도록 유도|
||NO_PUSH_SUBQ|서브쿼리를 가급적 늦게 필터링하도록 유도|

## Reference

- [친절한SQL 튜닝](https://product.kyobobook.co.kr/detail/S000001975837)