## 2.1 인덱스 구조 및 탐색

### 2.1.1 인덱스 튜닝

#### 인덱스 튜닝 핵심 요소

온라인 트랙잭션 처리(OLTP)시스템에서는 소량 데이터를 주로 검색하므로 큰 테이블에서 소량의 데이터를 검색할 때 사용하는 인덱스에 대한 튜닝이 중요하다. 인덱스 스캔과정에서 성능을 결정하는 인덱스 튜닝 요소는 여러가지가 있지만, 핵심요소는 크게 2가지가 있다  

`인덱스 스캔 효율화 튜닝` : 인덱스 스캔과정에서 발생하는 비효율을 줄이는 것. 어떻게 인덱스를 잡아 정렬 함에 따라 스캔 횟수를 줄일 수 있다.

`랜덤 액세스 최소화 튜닝` : 테이블 액세스 횟수를 최소화 시키는 것. 인덱스 스캔 후 테이블 레코드를 액세스할 때 랜덤 I/O 방식에 따라 액세스 횟수를 줄일 수 있다.

인덱스 스캔 효율화 튜닝보다 랜덤 액세스 최소화 튜닝이 성능에 미치는 영향이 더 크다. 스캔과정 보다 I/O 횟수가 성능 영향이 더 크기 때문이다. 즉, `SQL튜닝은 랜덤 I/O가 핵심`이라고 할 수 있다.

#### 랜덤 I/O
데이터베이스 성능이 느린 이유는 디스크 I/O 대부분을 차지 한다. 인덱스를 많이 사용하는 OLTP 시스템이라면 디스크 I/O 중에서도 랜덤 I/O가 특히 중요하다.  
IOT, 클러스터, 파티션에서부터 테이블 Prefetch, Batch I/O 등 DBMS가 제공하는 많은 기능은 랜덤 I/O을 극복하기 위해 개발되었다. 조인메소드 중 NL 조인이 대량 데이터 조인할 때 느린 이유도 랜덤 I/O 때문이고, 이를 극복하기 위해 소트머지 조인과 해시 조인이 개발되었다.

### 2.1.2 인덱스 구조

      인덱스 : 대용량 테이블에서 필요한 데이터만 빠르게 효율적으로 액세스하기 위해 사용하는 오브젝트


DBMS는 일반적으로 컬럼 기준으로 만든 `B * Tree 인덱스`를 사용한다. 루트와 브랜치 블록에 있는 각 레코드는 하위 브랜치 / 리프 블록에 대한 주소값을 가지고 있다. 루트와 브랜치 블록에는 Key 값(하위블록에 저장된 Key 값의 범위)을 갖지 않는 `Leftmost Child(LMC)`라는 컬럼을 가지고 있다. 가장 왼쪽 첫번째 레코드이고 자식 노드 중에 가장 왼쪽 끝에 위치한 블록을 가리킨다. 즉, 2번째 레코드 보다 작거나 같은 레코드가 저장되어 있다.  

![alt text](F30AF7A2-D02B-4585-8170-D21B95554279.jpeg)

리프 블록에 저장된 레코드는 Key 값 순으로 졍렬되었을 뿐만 아니라 테이블 레코드를 가리키는 주소값, 즉 `ROWID`를 갖는다. 인덱스 키값이 같으면 ROWID 순으로 정렬되어 있다. 이렇게 정렬되어있기 때문에 인덱스는 범위 스캔이 할 수 있다.

#### ROWID
ROWID는 데이터 블록주소(DBA) + ROW번호로 구성하기 때문에 이 값을 통해 테이블 레코드를 찾아갈 수 있다.  

- ROWID = 데이터 블록 주소 + 로우 번호
- 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
- 블록 번호 : 데이터 파일내에서 부여한 상대적 순번
- 로우 번호 : 블록 내 순번

### 2.1.3 인덱스 탐색

#### 인덱스 수직적 탐색

> 정렬된 인덱스 레코드 중에서 조건을 만족하는 첫번째 레코드를 찾는 과정, `인덱스 시작 지점`을 찾는 과정

루트 블록에서부터 시작하고, 레코드에 저장된 하위블록에 대한 주소값을 통해 리프 블록까지 수직적 탐색을 한다. 찾고자 하는 값보다 크거나 같은 값을 만나면 바로 직전 레코드가 가리키는 하위 블록으로 이동한다. 즉, 수직적 탐색은 조건을 만족하는 레코드를 찾아가는 과정이 아니라 `조건을 만족하는 첫번째 레코드`를 찾는 과정이다.

#### 인덱스 수평적 탐색

> 인덱스에서 본격적으로 데이터를 찾는 과정

수직적 탐색을 통해 스캔 시작점(첫번째 레코드)를 찾았으면 리프 블록을 수평적으로 탐색을 진행한다. 인덱스 리프 블록끼리는 서로 앞뒤 블록에 대한 주소값을 갖는다. 즉, 양방향 연결 리스트(double linked list)구조이기 때문에 좌우 혹은 우좌 수평적 탐색이 가능하다.  

수직적 탐색 뿐만 아니라 수평적 탐색도 진행하는 이유는 조건절에 만족하는 데이터를 모두 찾기위해서다. 또한, ROWID을 얻기 위해서다. 필요한 컬럼을 인덱스가 모두 갖고 있으면 끝내지만, 아닐 경우, 테이블을 액세스 해야하기 때문에 ROWID가 필요하다.

### 2.1.4 결합 인덱스 구조와 탐색

두개 이상 컬럼을 결합해서 인덱스를 만들 수 있다. 여기서 인덱스 컬럼 순서에 상관없이 스캔 방법은 같기 때문에 읽는 인덱스 블록 개수는 동일하다. 즉, 인덱스 컬럼을 "="조건으로 검색할 경우에는 어느 컬럼을 인덱스 앞쪽에 두든 순서와 상관없이 블록 I/O 개수가 같으므로 성능도 똑같다.

이는 인덱스 구조가 엑셀와 같은 평면구조가 아니고 B * Tree구조 이기 때문이다. B * Tree는 Balanced Tree이기 때문에 루트에서 루트 블록에 도달하기 까지 읽는 블록 수가 같음을 의미한다. 즉, **루트로부터 모든 리프 블록까지의 높이가 항상 같기 때문에 인덱스 탐색과정에 블록 I/O 갯수도 같다. 단, 이 경우는 인덱스 컬럼을 "="조건으로 검색할 경우이다.**

