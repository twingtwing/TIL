# 🧷 인덱스 구조

## 🖇️  인덱스 튜닝

온라인 트랙잭션 처리(OLTP)시스템에서는 소량 데이터를 주로 검색하므로 큰 테이블에서 소량의 데이터를 검색할 때 사용하는 인덱스에 대한 튜닝이 중요하다. 인덱스 스캔과정에서 성능을 결정하는 인덱스 튜닝 요소는 여러가지가 있지만, 핵심요소는 크게 2가지가 있다  

**✅ 핵심 요소**
- 인덱스 스캔 효율화 튜닝 : 인덱스 스캔과정에서 발생하는 비효율을 줄이는 것. 어떻게 인덱스를 잡아 정렬 함에 따라 스캔 횟수를 줄일 수 있다.
- 랜덤 액세스 최소화 튜닝 : 테이블 액세스 횟수를 최소화 시키는 것. 인덱스 스캔 후 테이블 레코드를 액세스할 때 랜덤 I/O 방식에 따라 액세스 횟수를 줄일 수 있다.

인덱스 스캔 효율화 튜닝보다 랜덤 액세스 최소화 튜닝이 성능에 미치는 영향이 더 크다. 스캔과정 보다 I/O 횟수가 성능 영향이 더 크기 때문이다. 즉, **`SQL튜닝은 랜덤 액세스 최소화가 핵심`** 이라고 할 수 있다.

데이터베이스 성능이 느린 이유는 디스크 I/O 대부분을 차지 한다. 인덱스를 많이 사용하는 OLTP 시스템이라면 디스크 I/O 중에서도 랜덤 I/O가 특히 중요하다.  

IOT, 클러스터, 파티션에서부터 테이블 Prefetch, Batch I/O 등 DBMS가 제공하는 많은 기능은 랜덤 I/O을 극복하기 위해 개발되었다. 조인메소드 중 NL 조인이 대량 데이터 조인할 때 느린 이유도 랜덤 I/O 때문이고, 이를 극복하기 위해 소트머지 조인과 해시 조인이 개발되었다.

그렇기 때문에 OLTP 시스템에서 인덱스 튜닝이 중요하다.

## 🖇️  인덱스 구조

> 인덱스는 대용량 테이블에서 필요한 데이터만 빠르고 효율적으로 액세스할 목적으로 사용하는 오브젝트다.

#### (1) 인덱스 기본 구조

여러 종류의 인덱스 중에서 가장 일반적으로 사용되는 B * Tree 인덱스 구조는 아래와 같다.

![인덱스 구조](https://drive.google.com/thumbnail?id=1wNoUEUXrxzUZRWVGuDzzGf0Z1D7Ls-NJ&sz=w1000)

루트를 포함한 브랜치 블록에 저장된 엔트리에는 하위 노드 블록을 찾아기기 위한 주소(DBA?) 정보를 가지고 잇다.  루트와 브랜치 블록에는 Key 값(하위블록에 저장된 Key 값의 범위)을 갖지 않는 `Leftmost Child(LMC)`라는 컬럼을 가지고 있다. 가장 왼쪽 첫번째 레코드이고 자식 노드 중에 가장 왼쪽 끝에 위치한 블록을 가리킨다. 즉, 2번째 레코드 보다 작거나 같은 레코드가 저장되어 있다. 

```
Leftmost Child(LMC)
브랜치 노드의 각 엔트리는 키 값과 하위 노드를 가리키는 블록 주소를 갖는다. 그런데 키 값을 갖지 않는 특별한 엔트리가 하나 있는데, 각 브랜치 노드의 첫번째 엔트리가 그렇다. 이를 LMC라고 브루기로한다.
다른 엔트리는 자신의 키 값과 같거나 큰 값을 담은 자식 노드 블록을 가리키는 반면, lmc는 명시적인 키 값을 갖지 않더라도 '키 값을 가진 첫번째 엔트리보다 작은 값'의 의미를 갖는다. 따라서 그 브랜치 블록의 자식 노드 중 가장 왼쪽 끝에 위치한 블록을 가리킨다.
```

최말단 리프 블록에는 인덱스 키 컬럼과 함께 해당 테이블 레코드를 찾아가기 위한 주소(ROWID) 정보를 갖는다. 리프 블록은 항상 키 컬럼 순으로 정렬돼 있기 때문에 범위 스캔이 가능하다. 인덱스 키값이 같을때는 ROWID 순으로 정렬되어 있다.  


**✅ 범위 스캔**

테이블은 처음부터 끝까지 모든 레코드를 읽어야 완전한 결과집합을 얻을 수 있지만, 인덱스는 키 컬럼 순으로 정렬돼 있기 때문에 특정 위치에서 스캔을 시작해 검색 조건에 일치하지 않는 값을 만나는 순간 멈출 수 있다. 즉, 인덱스를 통해서는 범위 스캔이 가능하다.

테이블도 범위 스캔이 가능한 경우가 있다.  IOT(index - organized  table)는 특정 컬럼순으로 정렬 상태를 유지하며 값을 입력하므로 범위 스캔이 가능하다. 이를 제외한다면 일반적인 힙 구조 테이블(heap-organized table)에서 범위 스캔은 있을 수 없다. 정렬 상태가 유지되도록 사용자가 아무리 주의 깊게 데이터를 입력한들, 옵티마이저가 그것을 신뢰해 Table Range Scan 같은 실행계획을 수립하진 않는다.

**??**

값이 null인지 여부에 상관없이 모든 레코드를 인덱스에 저장하는 DBMS가 있는가 하면 오라클은 인덱스 구성 컬럼이 모두 null인 레코드는 저장하지 않는다. 그리고 인덱스 구성컬럼이 모두 null인 경우를 제외하면, 인덱스와 테이블 레코드 간에는 서로 1:1 대응 관계를 갖는다. 단, 클러스터 인덱스는 1:M관계를 갖는다. 브랜치에 저장된 레코드 개수는 바로 하위 블록 개수와 일치한다. 

인덱스 리프 노드상의 레코드와 테이블 레코드 간에는 1:1 관계라고 했는데, 값도 서로 일치한다. 따라서  테이블 레코드 에서 값이 갱신되면 리프 노드 인덱스 키 값도 같이 갱신(delete&insert)된다. 반면, 리프 토드 상의 엔트리 키 값이 갱신되더라도 브랜치 노드까지 값이 바뀌지는 않는다. 브랜치 블록에 놓인 엔트리는 자신의 키 값과 같거나 큰 값을 담는 하위 노드 블록을 포인팅하는 것으로서, 그 키 값은 자식 노드가 갖는 값의 범위를 나타내기 때문이다. 따라서 키 값이 하위 노드의 첫 번째 레코드와 정확히 일치하지 않으며, 이는 위 그림에서 잘 표현된다. 참고로, 브랜치 노드는 인덱스 분할에 의해 새로운 블록이 추가되거나 삭제(다른 브랜치의 자식노드로 이동) 될때만 갱신된다. 즉 요약하자면,

- 리프 노드상의 인덱스 레코드와 테이블 레코드 간에는 1:1관계
- 리프 노드상의 키 값과 테이블 레코드 키 값은 서로 일치
- 브랜치 노드상의 레코드 개수는 하위 블록 개수와 일치
- 브랜치 노드상의 키 값은 하위 노드가 갖는 값의 범위를 의미

이런 인덱스 구조와 특징을 정확히 이해해야하만 인덱스 탐색과정도 쉽게 이해할 수 있다.


> B*Tree?


#### (2) ROWID
ROWID는 데이터 블록주소(DBA) + ROW번호로 구성하기 때문에 이 값을 통해 테이블 레코드를 찾아갈 수 있다.  

- ROWID = 데이터 블록 주소 + 로우 번호
- 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호
- 블록 번호 : 데이터 파일내에서 부여한 상대적 순번
- 로우 번호 : 블록 내 순번

rowid에는 데이터 파일 번호, 블록 번호, 로우 번호 같은 테이블 레코드의 물리적 위치 정보를 포함한다. 테이블 레코드를 찾아가는 데 필요한 주소 정보이므로 테이블 자체에 저장되는것이 아니라 인덱스에 저장한다. 필요하면 rowid를 출력해 볼 수 있지만 그 값이  테이블에  실제 저장돼 있지 않다. 즉, pseudo 컬럼이다.

그럼 인덱스를 거치치 않는 쿼리에서 rowid를 요구할때면 어떻게 그 값을 출력할까? 오브젝트 및 데이터파일 번호, 그리고 그 파일 내에서의 상대적인 블록 번호가 데이터 브록 헤더에 저장돼 있기 때문에 어렵지 않다.  레코드를 읽는 시점에 현재 도달한 블록 헤더와 각 레코드에 할당된 슬롯 번호를 이용해 층분히 가공해 낼 수 있는 것이다. 

오라클 7번전까지는 rowid는 내부적으로 6바이트 크기를 차지하면, 데이터 파일번호, 블록번호, 로우번호로 구성된다. 그러나 오라클 8부터는 rowid 크기를 10바이트로 증가시켰다.  데이터베이스에 저장해야 될 데이터량이 점차 증가해 더 많은 데이터 파일을 관리할 필요가 생겼고, 파티션 가은 기능을 저장하기 위해 오브젝트 번호까지 저장할 필요가 생겼기 때문이다. 

오라클 7 버전까지는 제한 rowid 포맷이라고 위에서 언급한 3개의 구성요소로 구성되지만, 8붜전부터는 '확장rowid포맷'은 제한 rowid 포맷에 데이터 오브젝트 번호를 더해 4개의 구성요소로 이루어진다.
- 데이터 오브젝트 번호 : 데이터베이스 세그먼트를 식별하기 위해 사용되는 데이터 오브젝트 번호
- 데이터파일 번호 : 로우가 속한 데이터 파일 번호 7에서는 데이터베이스내에서 유일한 값 8에서는  테이블 스페이스내에서의 상대적인 파일 번호
- 블록번호 : 해당 로우가 저장된 데이터 블록번호이면 데이터 파일내에서의 상대적 번호
- 로우 번호  : 블록내에서 각 로우에 붙여진 일려번호로서 0부터 시작됨


## 🖇️  인덱스 탐색

###  1. 인덱스 탐색

인덱스 탐색 과정을 수직적 탐색과 수평적 탐색으로 구분해 설명할 수 있다. 수평적 탐색은 앞서 강조했던 범위 스캔을 말하는 것이며,  리프 블록을 인덱스 레코드 간 논리적 순서에 따라 좌에서 우, 또는 우에서 좌로 스캔하기 때문에 수평적 이라고 표현한다.

#### (1) 인덱스 수직적 탐색

> 정렬된 인덱스 레코드 중에서 조건을 만족하는 첫번째 레코드를 찾는 과정, `인덱스 시작 지점`을 찾는 과정

수직적 탐색은 수평적 탐색을 위한 시작 지점을 찾는 과정이라고 할 수 있으며, 루트에서 리프 블록까지 아래쪽으로 진행하기 때문에 수직적이다.

루트 블록에서부터 시작하고, 레코드에 저장된 하위블록에 대한 주소값을 통해 리프 블록까지 수직적 탐색을 한다. 찾고자 하는 값보다 크거나 같은 값을 만나면 바로 직전 레코드가 가리키는 하위 블록으로 이동한다. 즉, 수직적 탐색은 조건을 만족하는 레코드를 찾아가는 과정이 아니라 `조건을 만족하는 첫번째 레코드`를 찾는 과정이다.

#### (2) 인덱스 수평적 탐색

> 인덱스에서 본격적으로 데이터를 찾는 과정

수직적 탐색을 통해 스캔 시작점(첫번째 레코드)를 찾았으면 리프 블록을 수평적으로 탐색을 진행한다. 인덱스 리프 블록끼리는 서로 앞뒤 블록에 대한 주소값을 갖는다. 즉, 양방향 연결 리스트(double linked list)구조이기 때문에 좌우 혹은 우좌 수평적 탐색이 가능하다.  

수직적 탐색 뿐만 아니라 수평적 탐색도 진행하는 이유는 조건절에 만족하는 데이터를 모두 찾기위해서다. 또한, ROWID을 얻기 위해서다. 필요한 컬럼을 인덱스가 모두 갖고 있으면 끝내지만, 아닐 경우, 테이블을 액세스 해야하기 때문에 ROWID가 필요하다.

### 2. 결합 인덱스 구조와 탐색

두개 이상 컬럼을 결합해서 인덱스를 만들 수 있다. 여기서 인덱스 컬럼 순서에 상관없이 스캔 방법은 같기 때문에 읽는 인덱스 블록 개수는 동일하다. 즉, 인덱스 컬럼을 "="조건으로 검색할 경우에는 어느 컬럼을 인덱스 앞쪽에 두든 순서와 상관없이 블록 I/O 개수가 같으므로 성능도 똑같다.

이는 인덱스 구조가 엑셀와 같은 평면구조가 아니고 B * Tree구조 이기 때문이다. B * Tree는 Balanced Tree이기 때문에 루트에서 루트 블록에 도달하기 까지 읽는 블록 수가 같음을 의미한다. 즉, **루트로부터 모든 리프 블록까지의 높이가 항상 같기 때문에 인덱스 탐색과정에 블록 I/O 갯수도 같다. 단, 이 경우는 인덱스 컬럼을 "="조건으로 검색할 경우이다.**
