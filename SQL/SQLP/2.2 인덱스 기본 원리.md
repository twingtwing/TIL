# 🧷 인덱스 기본 원리


## 🖇️ 인덱스 사용

인덱스는 정렬되어 있기 때문에, Leaf 블록에서 스캔 시작점부터 데이터가 없는 지점까지 중간에 스캔을 멈출 수 있다. 이렇게 Leaf 블록 일부만 스캔하는 경우를 `Index Range Scan`이라 한다. 즉, 스캔을 중간에 멈출 수 있어야지만, **인덱스를 정상적으로 사용한다**라고 할 수 있다.

반대로, 일부가 아닌 전체를 스캔하는 `Index Full Scan`이라 한다. 예를 들어, 인덱스 컬럼(선투컬럼) 가공할 경우에도 인덱스를 사용할 수 있지만, 리프 블록 전체를 스캔해야 하므로 인덱스를 정상적으로 사용한다고 할 수 없다. 이는 스캔 시작점을 찾을 수 없고, 스캔을 멈출 수 없기 때문이다.

(1) Index Range Scan

```SQL
SELECT EMPNO
FROM EMP
WHERE NAME LIKE 'ABD%'
```

      Leaf 블록

      [ABC] [ABE] [ABF]
               ↑
            스캔 정지
      

인덱스는 정렬되어 있기 때문에 [ABE] 뒤에 'ABD%'가 없음을 알 수 있다. 즉, 스캔 시작점을 알고 스캔을 멈출 수 있기 때문에 인덱스를 정상적으로 사용하고 있다고 할 수 있다.

(2) Index Full Scan

```SQL
SELECT EMPNO
FROM EMP
WHERE NAME LIKE '%ABD%'
```

      Leaf 블록

      [ABC] [ABE] [ABF]
               ↑
          스캔 정지 불가

조건절에 인덱스를 사용하였지만, [ABE] 뒤에 '%ABD%'가 없는지 알 수 없으므로 스캔을 도중에 멈출 수 없다. 또한, 중간값을 검색하기 때문에 스캔 시작점을 알 수 없다. 스캔 시작점과 끝지점을 모두 모르기 때문에 인덱스를 정상적으로 사용하고 있다고 할 수 없다.

B * Tree 인덱스를 정상적으로 사용하려면 범위 스캔 지점을 찾기위해 루트 블록부터 리프 블록까지의 수직적탐색을 거쳐야한다.  만약 인덱스 선두 컬럼이 조건절에 사용되지 않으면 범위 스캔 시작점을 찾을 수 없어 옵티마이저는 인덱스 전체를 스캔하거나 ㄷ테이블 전테를 스캔하는 방시긍 ㄹ선택한다. 또한, 인덱스 선두 컬럼이 범위 스캔이 불가능한 경우가 있다. 

#### 사용불가 혹은 범위 스캔 불가

인덱스 컬럼을 조건절에서 가공하면 정상적으로 인덱스를 사용할 수 없다.  부정형비교 <> != 을 사용해도 마찬가ㅈ이며 is not null 조건도 부정형 비교에 해당하므로 정상적이 인덱스 사용이 어렵다.

그러나 위 세 경우 모두 정상적인 인덱스 범위 스캔이 불가능한건지 인덱스 사용자체가 불가능한것은 아니다. 다시 말해, Index Full Scan은 가능하다.

여기서 is null 조건만을 검색 할 시에는 인덱스 사용이 불가능하다. 단일 컬럼 인덱스는 물론이고, 결합 인덱스더라도 구성 컬럼이 모두 null 이라면 인덱스만 뒤져서는 완전한 결과 집합을 얻을 수 없기 때문이다. is not null 의 경우 오라클은 단일 컬럼 인덱스에 null 값을 저장하지 않기 때문에 조건에 해당하는 레코드를 찾을 수 있으므로 인덱스 사용이 가능하다.

예외적으로 is null 조건에도 옵티마이저가 인덱스를 사용하는 경우가 잇긴 하다.  이는 is null 조건을 사용하는 컬럼이 not null 조건을 가지고 잇기 때문이다. 옵티마이저는 조건을 만족하는 레코드가 하나도 없음을 이미 알고 잇기 때문에 인덱스 스캔을 통해 공집합을 리턴하는 방식을 취한 것이다. 값이 null인 레코드는 인덱스에 포함되지 않으므로 이를 찾으려고 인덱스를 스캔하는 데에 논리적인 모순이 있지만, table full scan을 피하기 위한 일종의 트릭이라고 할 수있다.

is null 조건을 사용하더라도 다른 인덱스 구성 컬럼에 is null 이외의 조건식이 하나라도 있으면 index rangescan이 가능하다. 인덱스 구성 컬럼중 하나라도 null 값이 아닌 레코드는 인덱스에 저장되기 때문이다. 물론, 인덱스 선두 컬럼이 조건절이 누락되지 않아아야 한다. 참고로 오라클은 null 값을 맨뒤에 저장하고 mssql은 맨 앞에 저자아한ㄷ. 

만약 다른 인덱스 구성 컬럼중 어느하나에 not null제약이 설정돼 있다면, 그 컬럼에대한 조건식 유무에 상관없이 항상 index range scan 이 가능하다.

#### 인덱스 컬럼 가공

> 인덱스 컬럼을 가공할 경우, 인덱스를 정상적으로 사용(Range Scna)할 수 없다.

인덱스 컬럼을 가공하면 인덱스 스캔 시작점을 찾을 수 없기 때문에, Index Range Scan이 불가능 하다. 예를 들어 day BETWEEN 2023-12-01 AND 2023-12-31은 스캔 시작점과 끝지점을 알수 있지만, SUBSTR(day,5,2) = '12'의 경우 시작과 끝지점을 알 수 없기때문에 스캔을 멈출 수 없다. 

#### 묵시적 형변환

인덱스 컬럼을 가공하지 않았음에도 Tabel Full Scan이 일어나는 경우가 종종 있다. 형변환 함수를 생략하였음에도 옵티마이저가 자동으로 생성함으로써 인덱스 컬럼이 가공이 발생했기 때문이다. 즉, 자동 형변환 때문이다.

- 날짜형과 문자형이 만날 경우, 날짜형으로 자동 형변환 처리
- 숫자형과 문자형이 만날 경우, 숫자형으로 자동 형변환 처리
- LIKE연산자에서 숫자형과 문자형이 만날경우, 문자형으로 자동 형변환 처리

이러한 자동 형변환을 막기 위해, 인덱스 컬럼의 데이터 타입과 동일하게 포맷해서 조건절을 만들어야 한다. 

함수기반 인덱스(FBI) 활용
만약 개발 완료 시점에 성능 이슈가 발생했는데 원인이 묵시적 형변환에 있었고 프로그램을 일일이 바꿀 만큼 시간적 여유가 없다면 아래처럼 함수 기반 인덱스(FBI) 를 이용해 급한 불을 끌수 있다. 하지만 그다지 권장할 만한 해범은 못되므로 추후 일정을 잡아 반드시 개선해야한다.

FBI란?

#### OR/IN 연산자

OR, IN 연산자의 경우, 시작 지점을 알 수 없기 때문에 스캔 시작점을 찾을 수 없다. 그러나 UNION ALL와 옵티마이저의 쿼리 변환 기능을 사용하면  인덱스를 정상적으로 사용(Range Scna)할 수 있다. 

![alt text](../친절한_SQL_튜닝/스크린샷%202024-05-05%20오후%2011.19.06.png)

OR 연산자의 경우 UNION ALL을 사용해서 위와 같은 같은 형태로로 변형하면 Index Range Scan을 작동시킬 수 있다. OR 조건식를 SQL옵티마이저미가 위와 같은 형태로 변환할 수 있는데 이를 `OR Expansion`이라고 한다.

![alt text](or_test.png)

`use_concat`힌트를 통해 OR Expansion를 유도 할 수 있다.

![alt text](image-2.png)

IN 연산자도 스캔 시작점을 찾을 수 없지만, UNION ALL을 사용하면 각 브랜치별로 인덱스를 정상적으로 사용(Range Scna)할 수 있다. IN 조건절에서는 SQL 옵티마이저가 IN-List Iterator 방식을 사용한다. IN-List 개수만큼 Index Range Scan을 반복한다.

![alt text](image-1.png)

`use_concat`힌트를 통해 IN-List Iterator 방식을 사용하도록 유도할 수 있다.


## 🖇️  2.2.3 인덱스 사용 조건

`가공되지 않은 인덱스 선두 컬림이 조건절에 있어야 한다.` 인덱스 컬럼을 가공하지 않아도 선두 인덱스 컬럼을 조회하지 않으면 Range Scan을 하지 않는다. 반대로 생각하면, `인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에만 있으면 Index Range Scan은 무조건 가능하다.`

그러나 Index Range Scan을 한다하여도 성능이 좋은것은 아니다. 인덱스를 사용하더라도 인덱스가 스캔해야하는 데이터가 너무 많으면 인덱스를 잘 사용했다고 말할 수 없다. 그렇기 때문에 인덱스를 사용할 때, **인덱스 Leaf 블록에서 스캔하는 양을 확인하는 것이 좋다.**

## 🖇️  Sort 연산 생략

인덱스가 정렬됨으로써 Index Range Scan뿐 만 아니라 Sort 연산을 생략하는 효과를 얻을 수 있다. 선두 컬럼들을 모두 '='조건으로 사용하면 결과 집합은 바로 다음 인덱스 컬럼 순으로 정렬된채로 출력된다. 옵티마이저는 이런 속성때문에 SQL에 ORDER BY가 있어도 정렬 연산을 생략한다. 

![alt text](../친절한_SQL_튜닝/스크린샷%202024-05-05%20오후%2011.17.58.png)

실행계획에서도 SORT ORDER BY 연산이 생략되어 있음을 확인할 수 있다. 인덱스를 사용하지 않으면 SORT ORDER BY 단계가 추가되어 있다.  

내림차순(DESC) 정렬에도 마찬가지로 소트연산을 생략할 수 있다. 인덱스 Leaf 블록은 **양방향 연결 리스트**이기 때문에 양 방향으로 수직적, 수평적 탐색이 가능하기 때문이다. 오름차순(Asc)정렬일 때는 가장 작은 값을 찾아서 좌측으로 수직적 탐색한 후 우측으로 수평적 탐색을 한다. 내림차순(DESC)정렬일 때는 가장 큰 값을 찾아서 우측으로 수직적 탐색을 한 후 좌측으로 수평적 탐색을 한다. 

![alt text](../친절한_SQL_튜닝/스크린샷%202024-05-05%20오후%2011.19.06.png)

즉, 인덱스 탐색에서 반대로 하면 되기 때문에 실행 계획을 확인하면 SORT ORDER BY이 아닌 INDEX RANGE SCAN단계에 DESCENDING이 추가되어 있다.

#### 생략이 되지 않는 경우

```SQL
SELECT *
FROM ORDERS o 
WHERE o.STATUS = 'Pending'
AND o.CUSTOMER_ID BETWEEN 1 AND 100
ORDER BY o.ORDER_DATE 
```

결합 인덱스 구성이 [STATUS + CUSTOMER_ID + ORDER_DATE]일 경우, 위의 SQL을 정렬 연산이 생략되지 않는다. 이는, CUSTOMER_ID이 범위검색 조건 임에도 ORDER BY에 명시되지 않았기 때문이다. '=' 조건은 ORDER BY에 생략되어도 괜찮지만 아닐 경우는 명시 되어야 한다. 즉, 정렬 연산을 생략하기 위해서는 ORDER BY o.CUSTOMER_ID, o.ORDER_DATE 으로 조건절이 구성되어 있어야 한다. 이 외에도 조건절에 ORDER_DATE 조건절이 '='으로 추가 하면 정렬 연산을 생략할 수 있다.   

+ 액세스 조건까지만 정렬 연산 생략하는가..?

## 🖇️  조건 절 이외의 컬럼 가공

인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다. 이는 조건절 뿐만 아니라 ORDER BY 또는 SELECT-LIST에서도 인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용하지 못하는 경우가 발생할 수 있다.

#### ORDER BY

![alt text](../친절한_SQL_튜닝/스크린샷%202024-05-05%20오후%2011.56.41.png)

결합인덱스가 [STATUS + CUSTOMER_ID + ORDER_DATE] 구성한 경우, 조건절에 있는 선두컬럼이 가공되지 않았음에도 ORDER BY에 있는 인덱스 컬럼이 가공된 상태이기 때문에 정렬연산을 생략하지 않는다.

![alt text](../친절한_SQL_튜닝/스크린샷%202024-05-06%20오전%2012.13.35.png)

위의 SQL은 선두컬럼을 가공하지 않았고, ORDER BY에도 인덱스 컬럼이 가공되지 않았지만 SORT ORDER BY 연산이 발생했다. 이는 ORDER BY절에 사용된 ORDER_DATE 컬럼이 SELECT 절에서 가공된 컬럼을 지칭하고 있기 때문이다. 

![alt text](../친절한_SQL_튜닝/스크린샷%202024-05-06%20오전%2012.14.07.png)

ORDER BY절의 o.ORDER_DATE처럼 alias를 지정해주면 해결된다.

#### SELECT-LIST 

![alt text](../친절한_SQL_튜닝/스크린샷%202024-05-06%20오후%206.02.16.png)

결합인덱스가 [STATUS + CUSTOMER_ID + ORDER_DATE] 구성한 경우, 조건절에 있는 선두컬럼이 가공되지 않았기 때문에 정렬 연산 없이 최대 최솟값을 빠르게 찾을 수 있다. 인덱스 Leaf 블록의 왼쪽(MIN) 혹은 오른쪽(MAX)에서 레코드 하나만 읽고 멈추면 되기 때문에 실행계획에서 FIRST ROW를 확인할 수 있다.

![alt text](../친절한_SQL_튜닝/스크린샷%202024-05-06%20오후%206.03.14.png)

위의 SQL처럼 SELECT-LIST의 인덱스 컬럼이 가공되었을 경우, DATE 형식으로 정렬된 인덱스를 문자열 순으로 다시 재정렬해야하기 때문에 Sort 연산을 생략할 수 없다. TO_CHAR(MAX(o.ORDER_DATE),'YYYYMMDD')일 경우, Sort연산을 생략할 수 있다. 즉, 데이터 가공은 MAX 혹은 MIN 처리 후에 진행하면 인덱스를 정상적으로 사용할 수 있다.

![alt text](../친절한_SQL_튜닝/스크린샷%202024-05-06%20오후%207.14.16.png)

스칼라 서브쿼리에서도 마찬가지로 MIN/MAX와 FIRST ROW가 실행계획에서 정상적으로 작동됨을 확인 할 수 있다. 단, 12c 버전이상부터는 스칼라 서브쿼리를 Unnesting하기 때문에 no_unnest라는 힌트를 추가했다.  

이러한 스칼라 서브쿼리도 여러번 사용할수록, 테이블을 여러번 읽어야하기 때문에 비효울적이다. 또한, 스칼라 서브쿼리에서 여러 값을 출력하기 위해서 CONCAT과 같이 인덱스 컬럼을 가공하게 되면 정렬연산을 생략하지 않으므로 성능에 문제가 생길 수 있다.
