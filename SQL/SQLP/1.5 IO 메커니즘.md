# 🧷 I/O 메커니즘

## 🖇️ 블록 단위 I/O
데이터 I/O단위가 블록이기 때문에 특정 레코드를 읽고 쓰기 위해서는 해당 블록 전체를 읽어야 한다. 오라클은 기본적으로 8KB 크기의 블록을 사용하므로 1Byte를 읽기 위해 8KB를 읽어야 한다. 테이블 뿐만 아니라 인덱스도 블록단위로 데이터를 읽고 쓴다. 

```SQL
-- 블록 사이즈 확인

SHOW PARAMETER BLOCK_SIZE; -- 1번 방법

SELECT VALUE-- 2번 방법
FROM V$PARAMTER
WHERE NAME = 'db_block_size';
```

## 🖇️ 시퀀셜 액세스 VS 랜덤 액세스
테이블 또는 인덱스 블록에 액세스하는(=읽는) 방식으로는 시퀀셜 액세스와 랜덤 액세스가 있다.

#### 시퀀셜(Sequential) 액세스 
논리적 또는 물리적으로 연결된 순서에 따라 차례대로 블록을 읽는 방식이다. 

- 인덱스 블록 : 인덱스 리프 블록은 앞뒤를 가리키는 주소 값을 통해 논리적으로 연결돼 있다. 이 주소 값에 따라 앞/뒤로 순차적으로 스캔한다.

- 테이블 블록 
  - 논리적 연결 고리가 없기 때문에, 연결 정보를 따로 저장해서 관리한다.
  - 오라클의 경우, 세그먼트 헤더에 할당된 익스텐트 목록을 맵(Map)으로 관리한다.
  - `익스텐트 맵`은 각 익스텐트의 첫번째 블록 주소값(DBA)을 갖는다.
  - 읽어야 할 익스텐트 목록을 맵에서 얻고, 각 익스텐트의 첫 번째 블록뒤에 연속해서 저장된 블록을 순서대로 읽는다. 이러한 방식을 `Full Table Scan` 이라고 한다.

#### 랜덤(Random) 액세스
논리적, 물리적인 순서를 따르지 않고, 레코드 하나를 읽기 위해 한 블록씩 접근(=touch)하는 방식이다.

## 🖇️ 논리적 I/O VS 물리적 I/O

#### DB 버퍼캐시

SQL을 수행하는 과정에 계속해서 데이터 블록을 읽는데, 자주 읽는 블록을 매번 디스크에서 읽는 것은 매우 비효율적이고 SQL성능을 떨어뜨리는 일이다. 그렇기 때문에 DBMS에 데이터 캐싱 메커니즘이 필수적이다.

![SGA 구조](https://drive.google.com/thumbnail?id=1Adrwx75uurQqinruoR6CejmYhemXUwT_&sz=w1000)

데이터를 캐싱하는 `DBA 버퍼 캐시`도 라이브러리 캐시와 마찬가지로 SGA 구성요소 중 하나이다. 라이브러리 캐시가 코드 캐시이면 DB 버퍼 캐시는 '데이터 캐시'라고 할 수 있다.   

디스크에서 읽은 데이터 블록을 캐싱해 둠으로써 같은 블록에 대한 반복적인 I/O Call을 줄이는데 목적이 있다. 서버 프로세스에서 데이터 파일을 읽기 전에 항상 버퍼 캐시부터 먼저 탐색한다. 또한, 버퍼 캐시는 공유 메모리 영역이므로 같은 블록을 읽는 다른 프로세스도 I/O Call을 하지 않아도 된다.

#### 논리적 I/O VS 물리적 I/O

    논리적 I/O
        = SQL 처리하는 과정에 발생한 총 블록 I/O
        = 메모리 I/O (+ Direct Path I/O ← 메모리상의 버퍼 캐시를 경유하지 않는 경우 고려) 


SQL을 수행하면서 읽은 총 블록 I/O가 논리적 I/O이다. Direct Path Read 방식으로 읽는 경우를 제외하면 모든 블록은 DB 버퍼 캐시를 경유해서 읽는다. 따라서 논리적 I/O 횟수는 일반적으로 DB 버퍼 캐시에서 블록을 읽은 횟수와 일치한다. 논리적 I/O는 메모리 I/O와 개념은 다르디만, 결과적으로 수치는 같다.  

    물리적 I/O
        = 디스크 상에서 발생한 총 블록 I/O 
        = 메모리상의 버퍼 캐시에서 찾지 못한 일부 논리적 I/O
        = 디스크 I/O

DB버퍼캐시에서 블록을 찾지 못해 디스크에서 읽은 블록 I/O가 물리적 I/O이다. SQL을 실행할때마다 논리적 I/O는 같지만 물리적 I/O 값은 달라진다. 연속해서 SQL 실행할때마다 DB버퍼캐시에 해당 테이블 블록의 점유율이 높아지기 때문이다.

메모리 I/O는 전기적 신호인데 반해, 디스크 I/O는 액세스 암(Arm)을 통해 물리적 작용이 일어나기 때문에 메모리 I/O에 비해 상당히 느리다. 보통 10,000배 이지만, 디스크 경합이 심할 때는 더 느리다. 

#### 버퍼캐시 히트율

버퍼캐시 히트율은 버퍼캐시 효율을 측정하는 데 가장 많이 사용해오는 지표다. BCHR은 읽은 전체 블록 중에서 물리적인 디스크 I/O를 수반하지 않고 곧바로 메모리에서 찾은 비율이다. 

    BCHR = (캐시에서 곧바로 찾은 블록 수 / 총 읽은 블록 수) X 100
         = ((논리적 I/O - 물리적 I/O) / 논리적 I/O) X 100
         = (1 - 물리적 I/O / 논리적 I/O) X 100

SQL 성능을 높이기 위해서는 물리적 I/O가 아닌 논리적 I/O을 줄여야 한다. 논리적 I/O은 일정하므로 물리적 I/O는 BCHR에 따라 결정된다. BCHR은 시스템 상황에 달라지므로 물리적 I/O는 결국 시스템 상황에 따라 결정되는 통제하기 힘든 변수이다.(DB 버퍼캐시 크기를 늘리는 방법 외에) 즉, SQL 성능을 높이기 위해 할 수 있는 일은 논리적 I/O 줄이는 거다.

**그러면 어떻게 논리적 I/O을 줄일 수 있을까?**  

SQL을 튜닝해서 읽은 **총 블록 갯수**를 줄이면 된다. 논리적 I/O는 SQL 실행할 때 마다 항상 일정하지만, SQL튜닝을 통해 통제가능한 변수이다. 논리적 I/O을 줄임으로써 물리적 I/O을 줄이는 것이 곧 SQL 튜닝이다. BCHR이 SQL 성능을 좌우하지만, BCHR이 높다고 해도 SQL 효율이 높은 것은 아니다. 같은 블록을 비효율적으로 읽어도 BCHR은 높아질 수 있기 때문이다.

## 🖇️ Single Block I/O VS Multiblock I/O : 적재하는 방법

메모리 캐시가 클수록 좋지만, 데이터 모두 캐시에 적재할 수 없고 일부만 캐시에서 적재해서 읽을 수 있다. 캐시에서 찾지 못한 데이터 블록은 I/O Call을 통해 DB 버퍼 캐시로 적재하고 읽을 수 있다.

#### Single Block I/O 

>  Single Block I/O : I/O Call할 때, 한 번에 한 블록씩 요청해서 메모리에 적재하는 방식

[Single Block I/O 대상 오러페이션]
- 인덱스 루트 블록을 읽을 때
- 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
- 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
- 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때

인덱스를 이용할 때는 기본적으로 인덱스와 데이터 블록 모두 Single Block I/O 방식을 사용한다.

#### Multiblock I/O

> Multiblock I/O : I/O Call할 때, 디스크 상에 특정 블록과 인접한 블록들을 한꺼번에 읽어 캐시에 미리 적재하는 기능

이때 **인접한 블록은 같은 익스텐트에 속한 블록**을 의미한다. Multiblock I/O 방식은 익스텐트 경계를 넘지못한다는 의미이다. Data File 에서 익스텐트는 물리적으로 연속되어 있지만, 세그먼트는 물리적으로 연속되지 않기 때문이다.

```SQL
-- Multiblock I/O 블록 사이즈 조회
show parameter db_file_multiblock_read_count
```

많은 데이터 블록을 읽을 때 Multiblock I/O 방식이 효율적이다. 그래서 인덱스를 사용하지 않고 테이블 전체를 스캔할 때 이 방식을 사용한다. 또한, 테이블이 클수록 Multiblock I/O 단위도 클수록 좋다. I/O 횟수를 줄여서 프로세스가 대기 큐에서 실행 대기하는 횟수를 줄 일 수 잇다.

## 🖇️ Table Full Scan VS Index Range Scan

#### Table Full Scan  
테이블에 속한 블록 `전체`를 스캔해서 읽는 방식

#### Index Range Scan 
인덱스에서 `일정량`을 스캔하면서 얻은 ROWID로 테이블 레코드를 찾아가는 방식  
(ROWID : 테이블 레코드가 디스크 상에 어디 저장됐는지를 가리키는 물리적 저장위치 정보)

#### 성능 문제

Table Full Scan은 `시퀀셜 액세스`와 `Multiblock I/O` 방식으로 디스크 블록을 읽는다. 한 블록에 속한 모든 레코드를 읽고 캐시에서 못찾으면 **1번의 I/O Call**을 통해 인접한 수십 ~ 수백 개 블록을 한꺼번에 I/O 하는 매커니즘이다. 이 방식을 사용하는 SQL은 스토리지 스캔성능이 좋아지는 만큼 성능도 좋아진다.

이러한 방식은 큰 테이블에서 소량 데이터를 검색할 때는 비효율적이기 때문에 반드시 인덱스를 사용해야 한다. Index Range Scan을 통한 테이블 액세스는 `랜덤 액세스`와 `Single Block I/O` 방식으로 디스크 블록을 읽는다. 캐시에서 블록을 못 찾으면 레코드 하나를 읽기 위해 **1번 이상의 I/O Call**을 해야하는 I/O 매커니즘이다.  
이 방식을 사용하는 SQL은 스토리지 스캔 성능이 좋아져도 성능이 크게 좋아지지 않는다. 또한, 읽었던 블록을 또 반복해서 읽기 때문에 물리적 I/O뿐만 아니라 논리적 I/O측면에서도 비효율적이다.  

띠리서 소량의 데이터는 Index Range Scan이 좋지만 일정량을 넘는 대량의 데이터를 읽을 때는 Tabel Full Scan이 유리하다. Full Scan 하면 성능이 느려질거 같지만 인덱스를 이용해서 성능이 느려지는 경우가 많은 이유다.

### 1.3.8 캐시 탐색 메커니즘
Single Block I/O, Multiblock I/O 등 모든 블록 I/O 는 메모리 버퍼 캐시를 경유한다. (Direct Path I/O 제외)


[버퍼캐시 탐색 대상 오러페이션]
- 인덱스 루트 블록을 읽을 때
- 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을 때
- 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을 때
- 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을 때
- 테이블 블록을 Full Scan 할 때

#### 버퍼캐시 구조

DBMS는 버퍼 캐시는 해시 구조로 관리한다. 버퍼캐시에서 블록을 찾을때 해시 알고리즘을 통해 해시체인을 찾고, 체인에 연결된 버퍼 헤더에서 얻은 포인터(Pointer)를 이용해서 버퍼 블록을 액세스한다. 

![버퍼캐시 구조](https://drive.google.com/thumbnail?id=1x9uLoSmOC4JfOY3w23hMipsDHL2pqJXU&sz=w1000)

[ 해시 구조 특징 ]
- 같은 입력 값은 항상 동일한 해시 체인(=버킷)에 연결됨
- 다른 입력 값이 동일한 해시 체인(=버킷)에 연결될 수 있음
- 해시 체인 내에서는 정렬이 보장되지 않음

#### 메모리 공유자원에 대한 액세스 직렬화

**[래치(Latch)]**

SGA 구성요소인 버퍼캐시는 공유 메모리이기 때문에 동시 접근으로 인핸 `블록 정합성 문제`가 생길 수 있다. 이를 위해 내부에선 한 프로세스씩 순차적으로 접근하도록 구현해야하며, 이를 위해 직렬화 메커니즘이 필요하다. 직렬화가 가능하도록 지원하는 메커니즘이 `래치(Latch)`이다.

SGA를 구성하는 서브 캐시마다 별도의 래치가 존재하는데, 버퍼 캐시에는 `캐시버퍼 체인 래치`, `캐시 버퍼 LRU 체인 래치`등이 작동한다. 빠른 데이터 베이스를 구현하려면 버퍼 캐시 히트율을 높여야 한다. 하지만, 래치에 의한 경합으로 인해 캐시 I/O가 빠르지 않을 수 있다.

> 캐시버퍼 체인 래치

대량의 데이터를 읽을 때 모든 블록에 대해 해시체인을 탐색한다. DBA(Data Block Address)를 해시 함수에 입력하고 거기서 반환된 값으로 스캔해야할 해시체인을 찾는다. 이때, 스캔하는 동안 체인구조를 변경하는 일이 생기면 안된다. 이를 막기 위해 체인 래치가 존재한다. 진입 가능한 Key 값을 획득한 프로세스만이 체인으로 진입할 수 있다

> 캐시 버퍼 LRU 체인

버퍼 헤더는 해시 체인 뿐만 아니라 LRU 체인에 의해서도 연결돼 있다. 메모리는 유한한 자원이기 때문에 버퍼 캐시가 사용빈도가 높은 데이터 블록들 위주로 구성될 수 있도록 LRU(Least Recently Used) 알고리즘을 사용해 관리된다. 모든 버퍼 블록 헤더를 LRU 체인에 연결해 사용빈도 순으로 위치를 옮겼다가 Free 버퍼가 필요해질때마다 사용빈도가 낮은 데이터 블록들을 우선적으로 밀어냄으로써 자주 액세스되는 블록들이 캐시에 더 오래 남아있도록 관리한다.

**버퍼 LOCK**

캐시버퍼 체인 뿐만 아니라 버퍼 블록 자체에도 직렬화 메커니즘이 존재한다. 바로 버퍼 LOCK이다 이런 직렬화 메커니즘에 의한 캐시 경합을 줄이려면 SQL튜닝을 통해 쿼리 일량(논리적 I/O)자체를 줄여야 한다.

읽고자 하는 블록을 찾았으면 캐시버퍼 체인 래치를 해제해야 기다리던 다른 프로세스 들이 작업을 재개 할 수 있다. 래치를 해제한 상태로 버퍼 블록 데이터를 읽고 쓰는 중 후행 프로세스가 하필 같은 블록에 접근해서 읽고 쓴다면 데이터 정합성 문제가 생길 수 있다. 이를 방지하기 위해 오라클은 버퍼 LOCK을 사용한다. 캐시버퍼 체인 래치를 해제하기 전에 버퍼 헤더에 LOCK을 설정함으로 써 버퍼 블록 자체에 대한 직렬화 문제를 해결 하는 것이다.

## Reference

- [친절한SQL 튜닝](https://product.kyobobook.co.kr/detail/S000001975837)
- [오라클 성능고도화 원리와 해법 1](https://product.kyobobook.co.kr/detail/S000061696047)