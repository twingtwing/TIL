# 🧷 라이브러리 캐시 최적화

## 🖇️ 바인드 변수의 중요성

사용자 정의 함수/프로시저, 트리거, 패키지 등은 생성할 때부터 이름을 갖는다. 컴파일한 상태로 딕셔너리에 저장되며, 사용자가 삭제하지 않는 한 영구적으로 보관된다. 실행할 때 라이브러리 캐시에 적재함으로써 여러 사용자가 공유하면서 재사용한다.

반면, SQL은 이름이 없고 SQL텍스트가 이름 역활을 하고 딕셔너리에 저장하지도 않는다. 처음 최적화 과정을 거처 동적으로 생성한 내부 프로시저를 라이브러리 캐시에 적재함으로써 여러 사용자가 공유하면서 재사용한다. 캐시 공간이 부족하면 다시 버러졌다가 다음에 다시 실행할때 다시 최적화 과정을 거쳐서 재사용한다. --> 실습 필요

IBM DB2같은 DBMS는 SQL도 영구적으로 저장가능하지만, 오라클/SQL Server 같은 DBMS은 그렇게 하지 않는다. SQL자체가 이름이기 때문에 작은 부분이라도 정의 되면 같은 객체가 아니기 때문이다. 무수히 많은 객체들을 모두 저장하려하면 많은 공간이 필요하고, 그만큼 SQL을 찾는 속도도 느려기지 때문이다.

### 공유 가능 SQL

I/O가 거의 일어나지 않아도 동시다발적으로 발생하는 SQL 하드파싱으로 CPU사용률이 급격히 올라가서 DBMS에 부하가 발생할 수 있다. 예로 들어 이벤트로 인한 동시 시스템 접속으로 인한 로그인이 대량으로 발생하게 되었다. 이 때문에 각 고객에 대해 동시다발적으로 SQL 하드 파싱이 발생하게 된다. 라이브러리 캐시에는 각각 고객이 로그인할때마다 SQL 옵티마이저와 로우 생성기가 만든 내부 프로시저가 대량으로 적재하게 된다. 

이를 막기 위해 파라미터를 받는 공통 프로시저 하나를 만들어 공유하면서 재사용한다. 

    CREATE PROCEDURE LOGIN(id in varchar2) {}

이처럼 파라미터 Driven 방식으로 SQL을 작성하는 방법이 제공되는데, 바인드 변수가 바로 그것이다. 이를 사용한 경우 라이브러리 캐시를 조회하면 다수의 비슷한 SQL들이 아닌 아래의 SQL 하나만 발견된다. 

    SELECT * FROM TABLE FROM ID = :1

이 SQL에 대한 하드파싱은 최초 한번만 일어나고, 캐싱된 SQL은 여러 사용자에게 재사용되기 때문에 DBMS 부하를 줄일 수 있다.

## 🖇️ 세션 커서 캐싱 기능

## 🖇️ 애플리케이션 커서 캐싱



## Reference

- [친절한SQL 튜닝](https://product.kyobobook.co.kr/detail/S000001975837)
- [오라클 성능고도화 원리와 해법 1](https://product.kyobobook.co.kr/detail/S000061696047)