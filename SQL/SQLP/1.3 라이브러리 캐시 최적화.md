# 🧷 라이브러리 캐시 최적화

## 🖇️ 바인드 변수

### 1. Stored vs Transient

사용자 정의 함수/프로시저, 트리거, 패키지 등은 `Stored Object`이기 때문에 생성할 때부터 이름을 갖는다. 컴파일한 상태로 딕셔너리에 저장되며, 사용자가 삭제하지 않는 한 영구적으로 보관된다. 실행할 때 라이브러리 캐시에 적재함으로써 여러 사용자가 공유하면서 재사용한다.

반면, SQL은 `Transient Object`이기 때문에 이름이 없고 SQL텍스트가 이름 역활을 하고 딕셔너리에 저장하지도 않는다. 처음 최적화 과정을 거처 동적으로 생성한 내부 프로시저를 라이브러리 캐시에 적재함으로써 여러 사용자가 공유하면서 재사용한다. 캐시 공간이 부족하면 다시 버러졌다가 다음에 다시 실행할때 다시 최적화 과정을 거쳐서 재사용한다. 

IBM DB2같은 DBMS는 SQL도 영구적으로 저장가능하지만, 오라클/SQL Server 같은 DBMS은 그렇게 하지 않는다. SQL 자체가 이름이기 때문에 작은 부분이라도 다르면 같은 객체가 아니기 때문이다. 무수히 많은 객체들을 모두 저장하려하면 많은 공간이 필요하고, 그만큼 SQL을 찾는 속도도 느려기지 때문이다.

### 2. 바인드 변수의 중요성

#### 동시 다발적 하드 파싱 발생

I/O가 거의 일어나지 않아도 동시다발적으로 발생하는 SQL 하드파싱으로 CPU사용률이 급격히 올라가서 DBMS에 부하가 발생할 수 있다. 예로 들어 이벤트로 인한 동시 시스템 접속으로 인한 로그인이 대량으로 발생하게 되었다.  

for loop을 통해 조건절 비교 값을 변경해서 SQL을 실행 할 경우, 각각의 SQL에 대해 커서가 따로 생성되고 매번 하드 파싱을 발생시킨다. 또한, SQL 옵티마이저와 로우 생성기가 만든 내부 프로시저가 대량으로 적재하게 된다. 

#### 공유 가능한 SQL

이를 막기 위해 파라미터 Driven 방식으로 SQL을 작성하는 방법이 제공되는데, 바인드 변수가 바로 그것이다. 이를 사용한 경우 라이브러리 캐시를 조회하면 다수의 비슷한 SQL들이 아닌 아래의 SQL 하나만 발견된다. 

    SELECT * FROM TABLE FROM ID = :1

이 SQL에 대한 하드파싱은 최초 한번만 일어나고, 하나의 프로시저를 공유하면서 반복 재사용할 수 있게 되면서 아래와 같이 DBMS 부하를 줄일 수 있다.

- 커서를 많이 생성하지 않는다.
- 하나를 반복 재사용하므로 메모리 사용량과 파싱소요시간을 줄여준다.
- 메모리와 CPU 사용률을 낮춰 데이터베이스 성능과 확장성을 높이는데 기여한다.
- 동시 사용자 접속이 많을때, 높은 효율을 가지고 온다.

### 3. 바인드 변수의 부작용

바인드 변수를 사용하면 최초 수행할 때 최적화를 거친 실행계획을 캐시에 적재하고, 실행시점에는 그대로 가져와 값을 다르게 바인딩하면서 반복 재사용하게 된다. 이때 최적화하는 시점에 조건절 컬럼의 컬럼 히스토그램 정보를 사용하지 못한다. 따라서 평균 분포를 가정한 실행계획을 생성해서 사용하기 때문에 경우에 따라서 최적이 아닐 수 있다.

#### (1) 바인드 변수 Peeking

바인드 변수의 부작용을 극복하기 위해 오라클 9i부터 도입된 기능이다. SQL이 첫 번째 수행되면서 하드파싱될 때 함께 딸려 온 바인드 변수 값을 살짝 훔쳐 보고, 그 값에 대한 컬럼 분포를 이용해 실행계획을 결정하는 것이다. (SQL Server, Parameter Sniffing)

그러나, 실행계획을 잘못 수립된 경우 갑자기 느려지는 현상이 발생할 수 있다. 뿐만 아니라 자주 실행계획이 바뀌어 수행속도가 급격히 달라지는 현상이 발생할 수 있기 때문에 현재는 대부분 비활성된 상태로 운영중이다.

#### (2) 적응적 커서 공유(Adaptive Cursor Sharing)

11g에 도입된 기능으로, 입력된 바인드 변수 값의 분포에 따라 다른실행계획이 사용되도록 하는 것이다. 예를 들어, 선택도가 높은 조건절에 대한 테이블을 Full Scan 하는 실행계획을 수립하고 대항 커서를 반복 재사용중이다. 이대, 선택도가 매우 낮은 조건절 값이 입력되면,
컬럼 히스토그램을 확인해 본 후 인덱스를 이용하는 새로운 실행계획을 수립한다. 이렇게 두개의 Child 커서가 동시에 캐싱되어 선택도에 따라서 두 커서 중 1개를 재 사용한다. 만약에 현재 바인드 값을 처리할 커서가 캐싱되어 있지 않는다면, 하드파싱을 통해 새로운 실행계획을 생성한다. 

이 기능을 이용하려면 조건절 컬럼에 히스토그램이 생성돼 있어야 한다. 또한, 곧바로 실행계획을 생성하지 않고, 일단 기존의 커서를 그대로 사용해보고 성능이 나쁘다 판단되면 생성하는 단점이 존재한다.

#### (3) 입력 값에 따라 SQL 분리

인덱스 액세스 경로로서 중요하고 조건절 컬럼의 데이터 분포가 균일하지 않은 상황에서 바인드 변수 사용에 따른 부작용을 피하려면 바인딩 되는 값에 따라 실행계획을 아래와 같이 분리하는 방안을 고려해야 한다.

```SQL
SELECT /*+ FULL(A)*/ *
FROM TABLE 
WHERE :O IN ('A','B')
AND OPTION = :O
UNION ALL
SELECT /*+ INDEX(A IDX)*/ *
FROM TABLE 
WHERE :O NOT IN ('A','B')
AND OPTION = :O
```

단, 이러한 방식을 사용할 경우, SQL이 UNION ALL을 이용해 지나치게 길게 작셩하면 오히려 라이브러리 캐시 효율을 떨어뜨리게 된다. 예를 들어 UNION ALL에 의해 10개의 SQL이 결합된 상태에서 2개의 SQL만 주로 사용된다면 나머지는
불필요하게 공간만 낭비하게 된다. Parse 단계와 Execute 단계에서도 CPU를 과도하게 소비할 것이다.

#### (4) 예외적으로, Literal 상수값 사용

조건절 컬럼의 값 종류가 소수일 때는 바인드변수보다 오히려 Literal 상수를 사용하는 게 더 나을 수 있다. 왜냐하면, 입력 값 종류가 몇 개에 불과하다면 하드파싱 부하가 미미할 테고, Literal 상수를 사용함으로써 옵티마이저가 최적의 선택을 할 가능성이 커진다.
- 부등호나 Between 같은 범위 검색 조건절
- 배치프로그램이나 DW, OLAP 등 정보계시스템 
  - 기간 조건절이 많기 때문에, 거의 대부분 범위검색 조건절
  - 대부분 Long Running쿼리이므로 파싱 소요시간이 쿼리 총 소요시간에서 차지하는 비중이 낮고, 사용빈도가 낮아 하드파싱에 의한 라이브러리 캐시 부하를 걱정x
- 사용빈도가 아주 낮아 하드파싱에 의한 라이브러리 캐시 부하가 거의 없을 경우, OLTP 성 애플리케이션 상황에서도 사용한다.
  - 단, OLTP 환경에서는 이러한 특수한 경우를 제외하고는 반드시 바인드 변수를 사용해야 한다.

## 🖇️ 세션 커서 캐싱 기능

### 세션 커서 캐싱이란?

커서를 공유할 수 있는 형태로 SQL을 작성하면 하드파싱을 최소화 해 궁극적으로 시스템 확장성을 높일 수 있다. 하지만, 하드파싱을 하지 않더라도 SQL 구문을 분석해서 해시 값을 계산하고, Library cache 래치를 획득한 후 라이브러리 캐시에서
커서를 탐색하는 과정 자체도 부담이 되는 작업이다. 특히, SQL을 동시 수행이 많을 때는 경합이 발생하므로 시스쳄에 부하를 준다.

이러한 부하를 줄이기 위해서 Parse Call에 따른 부하를 줄일 수 있다. Shared Pool에 위치한 공유커서를 실행하기 위해 PGA로 인스턴스화 한것이 세션커서이다. 쿼리를 수행한 후에 커서를 닫으면 세션커서에 의해 할당된 메모리는 물론 공유 커서를 가리키는 포인터까지 바로 해제된다. 이후에 동일한 SQL을 수행하면 커서를 오픈하기 위한 라이브러리 캐시 탐색 작업을 다시 진행 해야 한다. 이에 오라클은 자주 수행하는 세션 커서를 세선 커서 캐시에 저장할 수 있는 기능을 제공하는데 이를 `세션 커서 캐싱`이라고 한다.

### 활성화 시

이 기능을 활성화 하면, 커서를 닫는 순간 해당 커서의 Parse Call 횟수를 확인해보고 그 값이 3보다 크거나 같으면, 세션 커서를 세션 커서 캐시로 옮긴다. 세션 커서 캐시에는 SQL 텍스트와 함께 공유 커서를 가리키는 포인터를 저장한다. 커서는 닫힌 상태지만, 공유 커서에 대한 참조를 유지하기 때문에 다음 수행 시 더 빨리 커서를 오픈할 수 있다. 따라서 자주 수행되는 SQL문에 의해 발생하는 라이브러리 캐시 부하를 경감 시킬 수 있다. 

즉, SQL문을 파싱해서 구문을 분석하고 라이브러리 캐시에서 커서를 찾는 과정에서 소모되는 CPU 사용량을 줄일 수 있음은 물론, 소프트 파싱 과정에서 발생하는 래치 요청 횟수를 감소 시키는 효과를 가져온다. 세션 커서 캐시 내에서도 LRU 알고리즘을 사용함으로서 새로운 엔트리를 위한 공간이 필요할 때마다 기존 세션 커서 중 사용 빈도가 낮은거부터 밀어낸다.

이때, 주의할 점은 세션 커서 캐싱 기능은 Parse Call을 줄이는 것이 아니라 Parse Call 부하를 감소 시키는 기능시킨다.

해당 기능은 PL/SQL에서는 SQL커서를 자동으로 캐싱해 주는데, 10G 부터는 이 기능이 session_cached_cursors 파라미터를 0보다 크게 설정할 때만 작동한다. 즉, 10g 이후 버전에서는 세션 커서 기능을 반드시 활성화 해야 한다.

## 🖇️ 애플리케이션 커서 캐싱

세션 커서를 캐싱하면 SGA의 공유 커서를 빠르게 찾아서 커서를 오픈할 수 있다. 하지만, 세션 커서 캐시에 있는 SQL을 수행하더라도 공유 커서 힙을 Pin하고 실행에 필요한 메모리 공간을 PGA에 할당하는 등의 작업은 반복하게 된다. 이러한 작업을 생략하고 빠르게 SQL을 수행하려면 애플리케이션 커서 캐싱 기능을 사용해야 한다. 해당 기능을 사용하면 공유커서를 Pin한 채 반복 수행하므로 Parse Call을 최초 한번만 발생하고 이후로는 발생하지 않는다. 

묵시적 캐싱 기능을 사용하기 위해서는 `implicit_caching` hint을 사용하면된다. PL/SQL에서는 해당 옵션을 사용하지 않더라도 자동적으로 커서를 캐싱한다. 단, Static SQL을 사용할때만 그렇다. Dynamic SQL을 사용하거나 Cursor Variable(=Ref Cursor)을 사용할 때는 커서를 자동으로 캐싱하는 효과가 사라진다. PL/SQL에서는 최대 몇개 SQL을 내부적으로 캐싱하는지는 오라클 9i부터는 open_cursor 파라미터에 의해 결정되지만, 10g부터는 새션커서기능과마찬가지로 session_cached_cursors파라미터에 의해 결정된다. 즉, 세션커서기능을 비활성화하면 PL/SQL의 자동 커서 캐싱 기능까지 비활성 된다.

n-Tier 환경에서는 DB Connection을 사용하고 나서 곧바로 커넥션 풀에 반환하므로 애플리케이션에 커서 캐싱 기법을 제대로 활용하기가 힘들다. 그러나, PL/SQL로 작성한 함수/프로시저를 적극적으로 사용하면 애플리케이션 커서 캐싱기법을 잘 활용할 수 있기 때문에 라이브러리 캐시 효율에 매우 높은 효과를 가지고 온다.

## 🖇️ Static SQL vs Dynamic SQL

- Static SQL : String형 변수에 담지 않고, 코드 사이에 직접 기술한 SQL문을 의미한다. 다른말로는 Embedded SQL이라고 한다.
- Dynamic SQL : String형 변수에 담아서 기술하는 SQL문, String 변수를 사용하므로 조건에 따라 SQL문을 동적으로 바꿀 수 있고, 런타임 시에 사용자로 부터 SQL문의 일부 또는 전부를 입력 받아서 실행할 수 있다. 
- Static SQL을 지원하는 개발 언어는 PowerBuilder, PL/SQL, Proc*C,SQLJ 뿐이고 이외에는 모두 Dynamic SQL을 지원한다. 
  
Static SQL, Dynamic SQL은 애플리케이선 개발 측면에서의 구분일 뿐, 데이터 베이스 입장에서는 동일한 SQL문으로 인식한다. 애플리케이션 커서 캐싱 기능을 활용하고자 하는 경우 외에는 성능에도 전혀 영향이 없다. 즉, 해당 기능을 사용하지 않으면 구분은 라이브러리 캐시 효율과는 전혀 무관하다. 그러므로 두 구분의 라이브러리 캐시 효율을 논할 때 캐싱 기능이 아닌 바인드 변수 사용 여부가 중요한 것이다. Dynamic SQL을 사용해 캐싱기능을 사용하지 않아서 문제가 아니라 바인드 변수를 사용하지 않았을때 문제가 있는 것이다. 

### Dynamic SQL 사용 기준

#### 

### Static SQL 사용 기준


## Reference

- [친절한SQL 튜닝](https://product.kyobobook.co.kr/detail/S000001975837)
- [오라클 성능고도화 원리와 해법 1](https://product.kyobobook.co.kr/detail/S000061696047)