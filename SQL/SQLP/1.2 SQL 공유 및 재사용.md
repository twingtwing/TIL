# 🧷 SQL 공유 및 재사용

## 🖇️ 소프트 파싱 VS 하드 파싱

`SGA(System Global Area)`는 서버 프로세스와 백그라운드 프로세스가 공통적으로 액세스하는 데이터와 제어구조를 캐싱하는 메모리 공간이다.
SGA 구성요소 중에 SQL파싱, 최적화, 로우 소스 생성 과정을 거쳐 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱해 두는 공간을 `라이브러리 캐시(Library Cache)(V$SQL)`이라고 한다. 즉, SQL과 실행 계획, DB 저장형 함수/프로시저 등을 캐싱하는 메모리 공간이고, `코드 캐시`라고도 부른다.

![SGA 구조](https://drive.google.com/thumbnail?id=1Adrwx75uurQqinruoR6CejmYhemXUwT_&sz=w1000)

SQL을 파싱 한 후에 해당 SQL이 라이브러리 캐시에 캐싱되어있는지 확인 후에 존재하면 곧바로 실행 한다. 이런 경우를 `소프트 파싱(Soft Parsing)`이라고 한다.  

존재하지 않을 경우, 최적화 및 로우 생성 단계를 거치는 것을 `하드 파싱(Hard Parsing)`이라고 한다. SQL 옵티마이저가 최적화 할때, 수맣은 경우의 수(실행경로)을 짧은 순간에 딕셔너리와 통계정보를 읽어 각각에 대한 효율성을 판단해야 하므로 많은 연산을 해야한다. 

[고려 요소]
- 테이블, 컬럼, 인덱스 구조에 관한 기본 정보
- 오브젝트 통계 : 테이블 통계, 인덱스 통계, (히스토그램을 포함한) 컬럼 통계
- 시스템 통계 : CPU 속도, Single Block I/O 속도, Multiblock I/O 속도 등
- 옵티마이저 관련 파라미터

데이터베이스에서 이루어지는 처리 과정은 대부분 I/O 작업에 집중되는 반면, **하드 파싱은 CPU를 많이 소비하는 몇 안되는 작업 중 하나**이다. 그렇기 때문에 이런 내부 프로시저를 재사용해서 비효율성을 줄여야할 필요가 있기 때문에 라이브러리 캐시가 필요하다.

## 🖇️ 바인드 변수의 중요성

사용자 정의 함수/프로시저, 트리거, 패키지 등은 생성할 때부터 이름을 갖는다. 컴파일한 상태로 딕셔너리에 저장되며, 사용자가 삭제하지 않는 한 영구적으로 보관된다. 실행할 때 라이브러리 캐시에 적재함으로써 여러 사용자가 공유하면서 재사용한다.

반면, SQL은 이름이 없고 SQL텍스트가 이름 역활을 하고 딕셔너리에 저장하지도 않는다. 처음 최적화 과정을 거처 동적으로 생성한 내부 프로시저를 라이브러리 캐시에 적재함으로써 여러 사용자가 공유하면서 재사용한다. 캐시 공간이 부족하면 다시 버러졌다가 다음에 다시 실행할때 다시 최적화 과정을 거쳐서 재사용한다. --> 실습 필요

IBM DB2같은 DBMS는 SQL도 영구적으로 저장가능하지만, 오라클/SQL Server 같은 DBMS은 그렇게 하지 않는다. SQL자체가 이름이기 때문에 작은 부분이라도 정의 되면 같은 객체가 아니기 때문이다. 무수히 많은 객체들을 모두 저장하려하면 많은 공간이 필요하고, 그만큼 SQL을 찾는 속도도 느려기지 때문이다.

### 공유 가능 SQL

I/O가 거의 일어나지 않아도 동시다발적으로 발생하는 SQL 하드파싱으로 CPU사용률이 급격히 올라가서 DBMS에 부하가 발생할 수 있다. 예로 들어 이벤트로 인한 동시 시스템 접속으로 인한 로그인이 대량으로 발생하게 되었다. 이 때문에 각 고객에 대해 동시다발적으로 SQL 하드 파싱이 발생하게 된다. 라이브러리 캐시에는 각각 고객이 로그인할때마다 SQL 옵티마이저와 로우 생성기가 만든 내부 프로시저가 대량으로 적재하게 된다. 

이를 막기 위해 파라미터를 받는 공통 프로시저 하나를 만들어 공유하면서 재사용한다. 

    CREATE PROCEDURE LOGIN(id in varchar2) {}

이처럼 파라미터 Driven 방식으로 SQL을 작성하는 방법이 제공되는데, 바인드 변수가 바로 그것이다. 이를 사용한 경우 라이브러리 캐시를 조회하면 다수의 비슷한 SQL들이 아닌 아래의 SQL 하나만 발견된다. 

    SELECT * FROM TABLE FROM ID = :1

이 SQL에 대한 하드파싱은 최초 한번만 일어나고, 캐싱된 SQL은 여러 사용자에게 재사용되기 때문에 DBMS 부하를 줄일 수 있다.


## Reference

- [친절한SQL 튜닝](https://product.kyobobook.co.kr/detail/S000001975837)
- [오라클 성능고도화 원리와 해법 1](https://product.kyobobook.co.kr/detail/S000061696047)