# 🧷 SQL 공유 및 재사용

## 🖇️ 라이브러리 캐시

Shared Pool 내에 위치하고, SQL 공유 커서, PL/SQL 오브젝트(컴파일을 거친 프로스저, 함수 등) 및 데이터베이스 오브젝트(테이블, 인덱스 등) 에 대한 정보를 정리하는 메모리 공간

![SGA 구조](https://drive.google.com/thumbnail?id=1Adrwx75uurQqinruoR6CejmYhemXUwT_&sz=w1000)

### 1. 캐시 정보의 종류와 분류 기준

#### (1) 라이브러리 캐시 오브젝트(LCO)

> 라이브러리 캐시 내 저장되는 정보 단위

- 실행가능 LCO : SQL 커서와 PL/SQL 오브젝트처럼 실행 가능한 오브젝트
- 오브젝트 LCO : 실행가능한 오브젝트 뿐만 아니라 참조하는 데이터 베이스 오브젝트 정보들을 하나의 오브젝트로서 관리
- LCO 각각에는 자신을 참조하는 다른 실행가능 LCO 목록을 갖는다.
  - 스키마 오브젝트 정보의 경우, 딕셔너리 캐시에도 캐싱되어 있음에도 LCO 간 의존성을 관리하기 위해 중복 저장 관리한다.
  
#### (2) 보관 기간

- Stored Object : 생성 후 Drop 하기 전까지 데이터 베이스에 **영구적**으로 보관되는 오브젝트 정보
  - 예 : 테이블, 인덱스, 클러스터, 뷰, 트리거, 패키지, 사용자 정의 함수/프로시저 등
  - 생성될때부터 이름을 가지는 것이 특징
- Transient Object : 실행시점에 생성돼서 인스턴스가 떠있는 동안에만 존재하는 일시적인 오브젝트 정보 (ex, Anonymous)
  - 예 : 커서, Anonymous PL/SQL문
  - 이름을 따로 지정하지 않으며, 문장을 구성하는 전체 문자열이 이름 역활을 한다.

### 2. 캐싱 관리 방법

#### LRU 알고리즘

라이브러리 캐시는 Shared Pool 내에 위치하기 때문에 **LRU 알고리즘**을 통해 관리되고 있다. (Shared Pool도 DB 버퍼 캐시 처럼 LRU 알고리즘 이용) 사용빈도가 낮은 SQL은 캐시에서 밀어냄으로써 새로운 SQL을 캐싱할 수 있도록 공간을 확보한다.

#### 해시구조

라이브러리 캐시도 DB 버퍼 캐시처럼 **해시 구조**로 괸리된다. 즉, 해시 버킷에 LCO 핸들(LOC을 식벽하고 힙을 포인트하는 데 사용)이 체인으로 연결돼 있고, 핸들을 통해 LCO 힙을 찾아가는 구조다. 해시 함수를 통해 리턴된 해시 값을 가지고 해시 버킷을 할당한다.

![라이브러리 캐시 해시 구조](https://drive.google.com/thumbnail?id=1MEyRcZOvxjeFtEMo5nVaJGiJoCjU6pVY&sz=w1000)

#### 커서 

오브젝트 LCO(테이블 정보)와 실행가능 LCO(SQL 커서)가 라이브러리 캐시에 함께 적재 되어있다. 커서는 Parent 커서 밑에 Child 커서가 연결되는 구조를 갖는다. SQL이 동일해도 커서를 공유하지 못하고, 커서를 별도로 생성해야할 때가 있는데, 그럴 때 **다중 Child 커서**를 사용한다.

### 3. Latch

> Latch : 메모리 내 자원에 대해 동시 접근 할 때, 조율하고 데이터의 일관성을 유지하도록 도와주는 일종의 잠금장치

#### (1) Shared Pool 래치

Shared Pool에서 특정 오브젝트 정보 또는 SQL 커서를 위한 Free Chunk를 할당 받으려 할 때 필요한 래치가 **Shared Pool 래치**이다. 이전에는 래치 1개로 관리하였지만, 9i부터는 7개까지 사용할 수 있다. 만약, 동시 사용자가 순간적으로 과도한 하드 파싱 부하를 일으킨다면 Shared Pool 래치에 대한 **경합현상**이 발생 할 수 있다.

#### (2) Library Cache 래치

DB 버퍼 캐시에서 체인에 연결된 리스트 구조를 보호하기 위해 Cache Buffers Chains 래치를 사용하는 것처럼 라이브러리 캐시 체인을 탐색하고 변경하려면 먼저 **Library Cache 래치**를 획득해야 한다. 이에 대한 경합이 발생할 때, **latch : library cache 대기 이벤트**가 발생한다.  

library cache가 많지 않기 때문에, 하드 파싱 뿐만 아니라 소프트 파싱이 많이 발생해도 래치에 대한 경합이 증가하게 된다.

#### (3) 라이브러리 캐시 Lock / Pin

DB 버퍼 캐시에서 버퍼 자체를 보호하려고 버퍼 Lock을 사용하는 것처럼 LCO를 보호하기 위해 라이브러리 캐시 Lock / Pin 을 사용한다. LCO에 접근할 때는 먼저 핸들에 대한 **Lock**을 획득해야 한다. 그러고 나서, LCO의 실제내용이 담긴 힙에서 정보를 읽거나 변경할 때는 **Pin**을 걸어두어야 한다. 즉, 라이브러리 캐시 힙을 Pin하려면 먼저 라이브러리 캐시 Lock을 획득해야 한다.

이를 통해 LCO을 읽고, 쓰고, 실행하는 동안 다른 프로세스에 의해 정보가 변경되거나 캐시에 밀려나는 것을 방지한다. Lock을 통해 LCO 핸들을 보호하고, Pin은 LCO에 실제로 담긴 Heap을 보호한다. 

#### (4) 경합현상

- shared pool 래치 / library catch 래치 경합은 소프트/하드 파싱을 동시에 심하게 일으킬때 발생
- library cache lock / pin 대기 이벤트는 주로 SQL 수행 도중 DDL을 날릴 때 발생

### 4. 라이브러리 캐시 최적화

1. 커서를 공유 할 수 있는 형태로 작성
   - 특히, 바인드 변수를 사용해 같은 형태의 SQL에 대한 반복적인 하드 파싱이 일어나지 않도록 처리
2. 세션 커서 캐싱 기능을 이용해 라이브러리 캐시에서 SQL 찾는 비용 감소 처리
3. 애플리케이션 커서 캐싱을 이용해 Parse Call 발생량을 감소 처리

## 🖇️ 커서 공유

### 1. Cursor란?

> 공유 커서 (Shared cursor) : 라이브러리 캐시에 공유돼 있는 Shared SQL Area

JAVA, PL/SQL 등에서 SQL을 수행하면, 서버 프로세스는 해당 SQL이 라이브러리 캐시에 공유돼 있는지를 먼저 확인한다. 없으면, 최적화 과정을 통해 실행계획을 만들고, 라이브러리 캐시에 공유한다. 그렇게 라이브러리 캐시에 공유돼 있는 Shared SQL Area를 '커서'라고 부른다.

> 세션 커서 (Session cursor) : Private SQL Area에 저장된 커서

Private SQL Area은 라이브러리 캐시에 공유돼 있는 커서를 실행할 때, PGA 영역에 할당되는 메모리를 말한다. Shared SQL Area를 읽어 커서를 실행하는 데 필요한 정보들을 Private SQL Area에 담고, 공유 커서를 가리키는 포인터를 유지할뿐만 아니라 커서의 상태 정보(open, bound, execute, close 등)도 관리한다.

커서를 오픈하면 라이브러리 캐시에 공유돼 있는 커서를 인스턴스화함으로써 PGA에 커서를 위한 메모리 공간을 할당하고, 실제 데이터 추출을 시작할 수 있도록 준비한다. 

> 애플리케이션 커서 (Application Cursor) : 세션 커서를 가리키는 핸들

PGA에 있는 커서를 핸들링하려면 JAVA, PL/SQ 같은 클라이언트 애플리케이션에도 리소스를 할당해야하는데 이를 커서라고 한다.

### 2. 커서 공유

    세션 커서, 애플리케이션 커서를 다른 프로세스와 공유할 수 없기 때문에 "커서를 공유한다."의 커서는 라이브러리 캐시의 공유 커서를 의미한다. 

라이브러리 캐시에 공유돼 있는 커서의 수행 통계는 `V$SQL`을 통해 조회 할 수 있다.
- parse_calls : 라이브러리 캐시에서 SQL 커서를 찾으려는 요청 횟수
- loads : 하드파싱을 거친 SQL 실행계획을 라이브러리 캐시에 적재한 횟수
- executions : SQL을 수행한 횟수
- invalidations : 커서가 무효화된 횟수
위의 정보를 통해 해당 SQL이 몇 번 하드파싱되었는지, 소프트 파싱되었는지 알 수 있다. 즉, 공유된 하나의 커서를 몇 번 재사용했는지 확인할 수 있다.ㄴ

### 3. 공유 불가

#### (1) Child cursor 공유 불가

SQL 문장이 100% 동일한대도 SQL 커서를 공유하지 못할 경우, 별도의 Child 커서를 생성한다. SQL 커서처럼 실행시점에 생성돼서 인스턴스가 떠있는 동안에만 존재하는 Transient Object는 이름을 따로 지정하지않고 문장을 구성하는 전체 문자열 그대로가 LCO를 식별하는 이름 역할을 한다. 그래서 전체 문자열은 같지만 다른 방식으로 실행해야 하거나, 파싱 스키마에 따라 다른 오브젝트를 참조하는 상황에서 Child 커서가 필요해진다.

즉, SQL마다 하나의 Parent 커서를 가지며, Child 커서는 여러개 일 수 있다. 그러나 version count 수치가 높은 SQL 일수록 커서를 탐색하는 데 더 많은 시간을 소비하므로 library cache 래치에 대한 경합 발생 가능성을 증가시킨다. 많은 SQL 커서를 갖는 구조일수록 라이브러리 캐시 효율이 나빠진다.

하나의 SQL 문장이 여러 개 Child 커서를 갖게 되는 이유
- SQL에서 참조하는 오브젝트명이 같지만, SQL을 실행한 사용자에 따라 다른 오브젝트를 가리킬 때
- 참조 오브젝트가 변경돼 커서가 무효화되면 이후 그 커서를 처음 사용하려는 세션에 의해 다시 하드파싱돼야 하는데, 특정 세션이 아직 기존 커서를 사용 중(Pin)일 때
- 옵티마이저 모드를 비롯해 옵티마이저 관련 파라미터가 다를 때
- 입력된 바인드 값의 길이가 크게 다를 때
- NLS 파라미터를 다르게 설정했을 때
- SQL 트레이스를 활성화 했을 때

#### (2) Parent cursor 공유 불가

의미적으로 같고 실행환경이 같은데도 커서를 공우히자 못해 Parent 커서 자체가 여러 개 생성 되는 경우
1. 공백 문자 또는 줄바꿈
2. 대소문자 구분
3. 테이블 Owner 명시
4. 주석
5. 옵티마이저 Hint
6. 조건절 비교 값 (바인드 변수를 사용하지 않고, Literal 값으로 문자열을 대체하는 경우)
다른 경우는 라이브러리 캐시 효율이 크게 나빠지지 않지만, 6번의 경우 좋은 성능을 보장할 수 없다. 이를 위해 바인드 변수를 사용한다.

## 🖇️ 소프트 파싱 VS 하드 파싱

`SGA(System Global Area)`는 서버 프로세스와 백그라운드 프로세스가 공통적으로 액세스하는 데이터와 제어구조를 캐싱하는 메모리 공간이다.
SGA 구성요소 중에 SQL파싱, 최적화, 로우 소스 생성 과정을 거쳐 생성한 내부 프로시저를 반복 재사용할 수 있도록 캐싱해 두는 공간을 `라이브러리 캐시(Library Cache)(V$SQL)`이라고 한다. 즉, SQL과 실행 계획, DB 저장형 함수/프로시저 등을 캐싱하는 메모리 공간이고, `코드 캐시`라고도 부른다.

![SGA 구조](https://drive.google.com/thumbnail?id=1Adrwx75uurQqinruoR6CejmYhemXUwT_&sz=w1000)

SQL을 파싱 한 후에 해당 SQL이 라이브러리 캐시에 캐싱되어있는지 확인 후에 존재하면 곧바로 실행 한다. 이런 경우를 `소프트 파싱(Soft Parsing)`이라고 한다.  

존재하지 않을 경우, 최적화 및 로우 생성 단계를 거치는 것을 `하드 파싱(Hard Parsing)`이라고 한다. SQL 옵티마이저가 최적화 할때, 수맣은 경우의 수(실행경로)을 짧은 순간에 딕셔너리와 통계정보를 읽어 각각에 대한 효율성을 판단해야 하므로 많은 연산을 해야한다. 

[고려 요소]
- 테이블, 컬럼, 인덱스 구조에 관한 기본 정보
- 오브젝트 통계 : 테이블 통계, 인덱스 통계, (히스토그램을 포함한) 컬럼 통계
- 시스템 통계 : CPU 속도, Single Block I/O 속도, Multiblock I/O 속도 등
- 옵티마이저 관련 파라미터

데이터베이스에서 이루어지는 처리 과정은 대부분 I/O 작업에 집중되는 반면, **하드 파싱은 CPU를 많이 소비하는 몇 안되는 작업 중 하나**이다. 그렇기 때문에 이런 내부 프로시저를 재사용해서 비효율성을 줄여야할 필요가 있기 때문에 라이브러리 캐시가 필요하다.

## 🖇️ 바인드 변수의 중요성

사용자 정의 함수/프로시저, 트리거, 패키지 등은 생성할 때부터 이름을 갖는다. 컴파일한 상태로 딕셔너리에 저장되며, 사용자가 삭제하지 않는 한 영구적으로 보관된다. 실행할 때 라이브러리 캐시에 적재함으로써 여러 사용자가 공유하면서 재사용한다.

반면, SQL은 이름이 없고 SQL텍스트가 이름 역활을 하고 딕셔너리에 저장하지도 않는다. 처음 최적화 과정을 거처 동적으로 생성한 내부 프로시저를 라이브러리 캐시에 적재함으로써 여러 사용자가 공유하면서 재사용한다. 캐시 공간이 부족하면 다시 버러졌다가 다음에 다시 실행할때 다시 최적화 과정을 거쳐서 재사용한다. --> 실습 필요

IBM DB2같은 DBMS는 SQL도 영구적으로 저장가능하지만, 오라클/SQL Server 같은 DBMS은 그렇게 하지 않는다. SQL자체가 이름이기 때문에 작은 부분이라도 정의 되면 같은 객체가 아니기 때문이다. 무수히 많은 객체들을 모두 저장하려하면 많은 공간이 필요하고, 그만큼 SQL을 찾는 속도도 느려기지 때문이다.

### 공유 가능 SQL

I/O가 거의 일어나지 않아도 동시다발적으로 발생하는 SQL 하드파싱으로 CPU사용률이 급격히 올라가서 DBMS에 부하가 발생할 수 있다. 예로 들어 이벤트로 인한 동시 시스템 접속으로 인한 로그인이 대량으로 발생하게 되었다. 이 때문에 각 고객에 대해 동시다발적으로 SQL 하드 파싱이 발생하게 된다. 라이브러리 캐시에는 각각 고객이 로그인할때마다 SQL 옵티마이저와 로우 생성기가 만든 내부 프로시저가 대량으로 적재하게 된다. 

이를 막기 위해 파라미터를 받는 공통 프로시저 하나를 만들어 공유하면서 재사용한다. 

    CREATE PROCEDURE LOGIN(id in varchar2) {}

이처럼 파라미터 Driven 방식으로 SQL을 작성하는 방법이 제공되는데, 바인드 변수가 바로 그것이다. 이를 사용한 경우 라이브러리 캐시를 조회하면 다수의 비슷한 SQL들이 아닌 아래의 SQL 하나만 발견된다. 

    SELECT * FROM TABLE FROM ID = :1

이 SQL에 대한 하드파싱은 최초 한번만 일어나고, 캐싱된 SQL은 여러 사용자에게 재사용되기 때문에 DBMS 부하를 줄일 수 있다.

## 🖇️ 세션 커서 캐싱 기능

## 🖇️ 애플리케이션 커서 캐싱

## Reference

- [친절한SQL 튜닝](https://product.kyobobook.co.kr/detail/S000001975837)
- [오라클 성능고도화 원리와 해법 1](https://product.kyobobook.co.kr/detail/S000061696047)