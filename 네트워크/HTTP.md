# HTTP
HyperText Transfer Protocol
(HyperText문서로 연결할 수 있는 프로토콜)

    http를 공부해야하는 이유

현재는 모든것이 HTTP메시지에 담아서 전송

http에 버전이 많지만, http/1.1을 가장 많이 사용 그 이상의 버전은 그저 성능개선에 초첨이 되어 있음

기반 프로토콜  
TCP : HTTP/1.1, HTTP/2    
UDP : HTTP/3  
현재 주로 HTTP/1.1 주로 사용하지만, 상위 버전도 점점 많이 사용하고 있음

## HTTP 특징
1. 클라이언트 서버 구조  
    - Request Response 구조  
    => client와 server로 분리된 개념  
    => client : UI,사용성(프론트)/ server : 비즈니스 로직,데이터(백엔드) 로 분리 시킴 (분산되지 않고, 집중 관리가 가능)
    - 클라이언트는 서버에 요청을 보내고, 응답을 대기
    - 서버가 요청에 대한 결과를 만들어서 응답
2. 무상태 프로토콜(스테이스리스)
    - 대용량 트래픽에서 매우 중요함?!
    - 서버가 클라이언트 상태를 보존하지 않음(이전상태를 보존하지 않음)  
    => 그래서, client가 필요한 정보를 한번에 말하는 문법을 가지게 되고, 다른 서버를 만나도 에러가 발생하지 않음
    => 중간에 다른 서버로 바껴도 에러가 나지 않기때문에, 요청이 증가해도 서버를 대거 투입할 수 가 있음  
    => 무상태는 응답서버를 쉽게 바꿀 수 있음 -> 무한한 서버 증설 가능  
    => 상태유지는 중간에 다른 서버가 바뀌면 그 이전상태 정보를 client가 알려주지 않기때문에 에러가 발생함 -> 계속 동일 서버와 통신을 해야함(중간에 장애가 나서 다른 서버로 교체 되면 에러가 발생함)
    - 장점 : 서버 확장성 높음(스케일 아웃(서버를 엄청나게 증설?) - 수평 확장 유리)  
        [ 실문한계 ]
        - 모든것을 무상태로 설계할 수 있는 경우도 있고 없는 경우도 있음 => 상태를 유지해야하는 경우가 있음
        - 로그인의경우 로그인이라는 상태를 서버에 유지해야함
        - 일반적으로 브라우저 쿠키와 서버 세션등을 사용해서 상태 유지
        - 상태 유지는 최소한만 사용
    - 단점 : 클라이언트가 추가 데이터 전송 (데이터를 많이 보냄?)
3. 비연결성
    - 최소한의 자원을 유지하고, 서버 자원을 효율적으로 사용
    - 일반저긍로 초단위의 이하의 빠른 속도로 응답
    - 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작음
    - 단점
        - 다시 TCP/IP 연결을 새로 맺어야함 - 3way handshake 시간 추가
        - 웹 브라우저로 사이트를 요청하면 HTML뿐만 아니라 자바스크립트,css,추가 이미지 등 수많은 자원이 함께 다운로드 됨
        - 지금은 HTTP 지속연결로 문제 해결
            => 연결 -> 모두 요청할때까지 연결을 끊지 않고 지속 연결 유지 -> 종료
        - HTTP/2, HTTP/3에서 더 많은 최적화
4. HTTP 메시지를 통해 통신  
    HTTP 메시지 구조  
    start - line (시작라인) : request-line / statue-line  
    - request-line : HTTP 메서드 SP(공백) 요청대상(/path?query string)  SP(공백) HTTP Version 
    - statue-line(응답메세지) : HTTP Version SP status-code SP reason-phrase(이유문구:사람이 이해할수 있는 짧은 상태 코드 설명 )

    header (헤더) : field-name:OWS(뛰어쓰기) field-value  
        [ 용도 ] : HTTP전송에 필요한 모든 부가정보 

    empty line (공백라인 CRCF)
    message body : 실제 전송할 데이터, HTML문서/JSON/image등등 byte로 표현할 수 있는 모든 데이터 전송가능 
5. 단순함, 확장 가능 : 크게 성공하는 표준기술은 단순하지만, 확장 가능한 기술

## HTTP 메서드
     
     API URI 설계 시 가장 중요한 것은 리소스
리소스는 의미는 무엇일까?
- 회원은 등록하고 수정하고 조회하는것이 리소스가 아니고, 회원이라는 개념 자체가 바로 리소스  

리소스를 어떻게 식별하는게 좋을까?
- 회원을 등록하고 수정하고 조회하는것는 모두 배제
- 회원이라는 리소스만 식별하면 됨 -> 즉, 회원리소스를 URI에 매핑

ARI URI 설계 시

    리소스 식별, URI 계층 구조 활용
    + 참고) 계층 구조상 상위를 컬렉션으로 보고 복수단어 사용 권장(ex, members)
- 회원목록 조회 : /members => GET
- 회원조회 : /members/{id} => GET
- 회원등록 : /members/{id} => POST
- 회원수정 : /members/{id} 
- 회원삭제 : /members/{id} 

=> 회원이라는 리소스만 식별하니 행위를 구분할 수가 없음

=> 즉, URI는 리소스만 식별 (리소스와 행위을 분리)

=> 리소스 : 명사, 행위 : 동사


그러면, 행위(메서드)는 어떻게 구분하는가? HTTP 메서드르 통해 구분함

### HTTP 메서드 종류
- GET : 리소스 조회 (조회의 경우는 거의 GET을 사용함)
    - 서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 쿼리 스트링)를 통해서 전달
    - 메시지 바디를 사용해서 데이터를 전달할 수 있지만, 지원하지 않는 곳이 많아서 권장하지 않음 
- POST : 요청 데이터를 처리하도록 요청, 주로 등록에 사용하는거지 등록만 하는게 아님
    - <b>메시지 바디</b>를 통해 서버로 요청 데이터 전달
    - 서버는 요청 데이터를 처리 
        - 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능들을 수행함
    - 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용
    - POST는 요청데이터를 어떻게(HOW) 처리할지는 리소스마다 따로 정해야함(정해진것이 없음)

        => 리소스에 리소스 대상뿐만 아니라 HOW가 들어가야함
        
        POST 정리(쓰임새)

    1. 새 리소스 생성(등록) : 서버가 아직 식별하지 않은 새 리소스 생성 
    2. 요청 데이터 처리 (중요)
        - 단순히 데이터를 생성하거나, 변경하는 것을 넘어서 프로세스를 처리해야하는 경우
        - POST의 결과로 새로운 리소스가 생성되지 않을 수 있음(등록하지않는 경우)
        - 컨트롤 URI : /orders/{orderId}/start-delivery
    3. 다른 메서드로 처리하기 애매한 경우 : 애매하면 POST (Json으로 조회하고 싶은 경우)

---
put : update로 대부분 사용  

정의한 사람 마음이기 때문에 나중에 따로 공부해서 수정
- PUT :
    - 리소스를 대체
        - 리소스가 있으면 대체 (완전히 대체 : 필드를 잘못입력하거나 빼먹은 상태에서 입력하면 잘못된 데이터로 완전이 대체하게됨)

            => 즉 수정이 아님, 완전히 대체 하는 것
        - 리소스가 없으면 생성
         
        => 쉽게이야기해서 덮어버림
    - 중요! 클라이언트가 리소스를 식별
        - 클라이언트가 리소스 위치를 알고 URI 지정
        - POST와 차이점

- PATCH : 리소스 부분 변경 (수정하고 싶을 경우 사용)
    - 데이터를 부분적으로 대체가 아닌 변경을 하고 싶을 경우 사용
    - 지원되지 않은 경우에는 POST를 사용
- DELETE : 리소스 삭제

기타(참고만?)
- HEAD : GET과 동일하지만 HTTP메시지 에서 메시지(body?) 부분을 제외하고, 상태 줄과 헤더만 반환
- OPTIONS : 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명(주로 CORS에서 사용)
- CONNECT : 대상 자원으로 식별되는 서버에 대한 터널을 설정
- TRACE : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행

### HTTP 메서드 속성

- 안전(Safe Methods) : 호출해도 리소스를 변경하지 않음 (GET O, POST X)
- 멱등(Idempotent Methods) : 한 번 호출하든 두 번 호출하든 100번 호출하든 결과가 똑같다
    - GET : 한번 조회 하든, 두번 조회한든 같은 결과 조회 => 멱등
    - PUT : 결과를 대체, 따라서 같은 요청을 여러번해도 덮어버리기 때문에 최종결과는 같음 => 멱등
    - DELETE : 결과를 삭제, 같은 요청을 여러번해도 삭제된 결과는 같음 => 멱등
    - POST : 두번 호출하면 같은 결제가 중복해서 발생할 수 있기 때문 => 멱등아님
    - 활용?? :
        - 자동 복구 메커니즘(똑같은 요청을 두번해도 됨?)
        - 서버가 TIMEOUT등으로 정상 응답을 못 주었을 때, 클라이언트가 같은 요청을 다시 해도 되는가? 판단 근거
    - 멱등은 외부요인으로 중간에 리소스가 변경되는 것까지는 고려하지 않음
- 캐시 가능(Cacheable Methods)
    - 응답 결과 리소스를 캐시해서 사용해도 되는가?
    - GET,HEAD,POST,PATCH 캐시가능
    - 실제로도 GET,HEAD정도만 캐시로 사용
        - POST, PATCH는 본문 내용까지 캐시 키로 고려해야 하는데, 구현이 쉽지 않음

### HTTP 메서드 활용

#### 클라이언트에서 서버로 데이터전송
> 데이터 전달 방식
1. 쿼리 파라미터를 통한 데이터 전송 
    - GET
    - 주로 정렬 필터(검색어, 정렬 조건)
2. HTTP 메시지 바디를 통한 데이터 전송
    - POST, PUT, PATCH
    - 회원가입, 상품주문, 리소스 등록, 리소스 변경

>클라이언트에서 서버로 데이터전송 상황
1. 정적 데이터 조회(쿼리 파라미터 미사용) : 이미지, 정적 텍스트 문서
2. 동적 데이터 조회(쿼리 파라미터 사용) : 주로 검색, 게시판 목록에서 정렬 필터(검색어)
3. HTML Form을 통한 데이터 전송 : 회원가입, 상품주문, 데이터변경
4. HTTP API를 통한 데이터 전송
    - 회원가입, 상품주문, 데이터 변경
    - 서버 to 서버, 앱 클라이언트, 웹 클라이언트(Ajax)

#### HTTP API 설계예시

## HTTP 상태코드