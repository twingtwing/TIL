# HTTP

=> 추신 네트워크 디지면서 공부
=> RFC 7230 ~ 7235 HTTP 스펙을 보고 공부해야함 그 전 스펙은 안됨(개정전임)공부할때도 확인해야함

HyperText Transfer Protocol
(HyperText문서로 연결할 수 있는 프로토콜)

    http를 공부해야하는 이유

현재는 모든것이 HTTP메시지에 담아서 전송

http에 버전이 많지만, http/1.1을 가장 많이 사용 그 이상의 버전은 그저 성능개선에 초첨이 되어 있음

기반 프로토콜  
TCP : HTTP/1.1, HTTP/2    
UDP : HTTP/3  
현재 주로 HTTP/1.1 주로 사용하지만, 상위 버전도 점점 많이 사용하고 있음

## HTTP 특징
1. 클라이언트 서버 구조  
    - Request Response 구조  
    => client와 server로 분리된 개념  
    => client : UI,사용성(프론트)/ server : 비즈니스 로직,데이터(백엔드) 로 분리 시킴 (분산되지 않고, 집중 관리가 가능)
    - 클라이언트는 서버에 요청을 보내고, 응답을 대기
    - 서버가 요청에 대한 결과를 만들어서 응답
2. 무상태 프로토콜(스테이스리스)
    - 대용량 트래픽에서 매우 중요함?!
    - 서버가 클라이언트 상태를 보존하지 않음(이전상태를 보존하지 않음)  
    => 그래서, client가 필요한 정보를 한번에 말하는 문법을 가지게 되고, 다른 서버를 만나도 에러가 발생하지 않음
    => 중간에 다른 서버로 바껴도 에러가 나지 않기때문에, 요청이 증가해도 서버를 대거 투입할 수 가 있음  
    => 무상태는 응답서버를 쉽게 바꿀 수 있음 -> 무한한 서버 증설 가능  
    => 상태유지는 중간에 다른 서버가 바뀌면 그 이전상태 정보를 client가 알려주지 않기때문에 에러가 발생함 -> 계속 동일 서버와 통신을 해야함(중간에 장애가 나서 다른 서버로 교체 되면 에러가 발생함)
    - 장점 : 서버 확장성 높음(스케일 아웃(서버를 엄청나게 증설?) - 수평 확장 유리)  
        [ 실문한계 ]
        - 모든것을 무상태로 설계할 수 있는 경우도 있고 없는 경우도 있음 => 상태를 유지해야하는 경우가 있음
        - 로그인의경우 로그인이라는 상태를 서버에 유지해야함
        - 일반적으로 브라우저 쿠키와 서버 세션등을 사용해서 상태 유지
        - 상태 유지는 최소한만 사용
    - 단점 : 클라이언트가 추가 데이터 전송 (데이터를 많이 보냄?)
3. 비연결성
    - 최소한의 자원을 유지하고, 서버 자원을 효율적으로 사용
    - 일반저긍로 초단위의 이하의 빠른 속도로 응답
    - 1시간 동안 수천명이 서비스를 사용해도 실제 서버에서 동시에 처리하는 요청은 수십개 이하로 매우 작음
    - 단점
        - 다시 TCP/IP 연결을 새로 맺어야함 - 3way handshake 시간 추가
        - 웹 브라우저로 사이트를 요청하면 HTML뿐만 아니라 자바스크립트,css,추가 이미지 등 수많은 자원이 함께 다운로드 됨
        - 지금은 HTTP 지속연결로 문제 해결
            => 연결 -> 모두 요청할때까지 연결을 끊지 않고 지속 연결 유지 -> 종료
        - HTTP/2, HTTP/3에서 더 많은 최적화
4. HTTP 메시지를 통해 통신  
    HTTP 메시지 구조  
    start - line (시작라인) : request-line / statue-line  
    - request-line : HTTP 메서드 SP(공백) 요청대상(/path?query string)  SP(공백) HTTP Version 
    - statue-line(응답메세지) : HTTP Version SP status-code SP reason-phrase(이유문구:사람이 이해할수 있는 짧은 상태 코드 설명 )

    header (헤더) : field-name:OWS(뛰어쓰기) field-value  
        [ 용도 ] : HTTP전송에 필요한 모든 부가정보 

    empty line (공백라인 CRCF)
    message body : 실제 전송할 데이터, HTML문서/JSON/image등등 byte로 표현할 수 있는 모든 데이터 전송가능 
5. 단순함, 확장 가능 : 크게 성공하는 표준기술은 단순하지만, 확장 가능한 기술

## HTTP 메서드
     
     API URI 설계 시 가장 중요한 것은 리소스
리소스는 의미는 무엇일까?
- 회원은 등록하고 수정하고 조회하는것이 리소스가 아니고, 회원이라는 개념 자체가 바로 리소스  

리소스를 어떻게 식별하는게 좋을까?
- 회원을 등록하고 수정하고 조회하는것는 모두 배제
- 회원이라는 리소스만 식별하면 됨 -> 즉, 회원리소스를 URI에 매핑

ARI URI 설계 시

    리소스 식별, URI 계층 구조 활용
    + 참고) 계층 구조상 상위를 컬렉션으로 보고 복수단어 사용 권장(ex, members)
- 회원목록 조회 : /members => GET
- 회원조회 : /members/{id} => GET
- 회원등록 : /members/{id} => POST
- 회원수정 : /members/{id} 
- 회원삭제 : /members/{id} 

=> 회원이라는 리소스만 식별하니 행위를 구분할 수가 없음

=> 즉, URI는 리소스만 식별 (리소스와 행위을 분리)

=> 리소스 : 명사, 행위 : 동사


그러면, 행위(메서드)는 어떻게 구분하는가? HTTP 메서드르 통해 구분함

### HTTP 메서드 종류
- GET : 리소스 조회 (조회의 경우는 거의 GET을 사용함)
    - 서버에 전달하고 싶은 데이터는 query(쿼리 파라미터, 쿼리 스트링)를 통해서 전달
    - 메시지 바디를 사용해서 데이터를 전달할 수 있지만, 지원하지 않는 곳이 많아서 권장하지 않음   
    - 리소스 변경이 발생하는 곳에 사용하면 안됨
- POST : 요청 데이터를 처리하도록 요청, 주로 등록에 사용하는거지 등록만 하는게 아님
    - <b>메시지 바디</b>를 통해 서버로 요청 데이터 전달
    - 서버는 요청 데이터를 처리 
        - 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능들을 수행함
    - 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용
    - POST는 요청데이터를 어떻게(HOW) 처리할지는 리소스마다 따로 정해야함(정해진것이 없음)

        => 리소스에 리소스 대상뿐만 아니라 HOW가 들어가야함
        
        POST 정리(쓰임새)

    1. 새 리소스 생성(등록) : 서버가 아직 식별하지 않은 새 리소스 생성 
    2. 요청 데이터 처리 (중요)
        - 단순히 데이터를 생성하거나, 변경하는 것을 넘어서 프로세스를 처리해야하는 경우
        - POST의 결과로 새로운 리소스가 생성되지 않을 수 있음(등록하지않는 경우)
        - 컨트롤 URI : /orders/{orderId}/start-delivery
    3. 다른 메서드로 처리하기 애매한 경우 : 애매하면 POST (Json으로 조회하고 싶은 경우)

---
put : update로 대부분 사용  

정의한 사람 마음이기 때문에 나중에 따로 공부해서 수정
- PUT :
    - 리소스를 대체
        - 리소스가 있으면 대체 (완전히 대체 : 필드를 잘못입력하거나 빼먹은 상태에서 입력하면 잘못된 데이터로 완전이 대체하게됨)

            => 즉 수정이 아님, 완전히 대체 하는 것
        - 리소스가 없으면 생성
         
        => 쉽게이야기해서 덮어버림
    - 중요! 클라이언트가 리소스를 식별
        - 클라이언트가 리소스 위치를 알고 URI 지정
        - POST와 차이점

- PATCH : 리소스 부분 변경 (수정하고 싶을 경우 사용)
    - 데이터를 부분적으로 대체가 아닌 변경을 하고 싶을 경우 사용
    - 지원되지 않은 경우에는 POST를 사용
- DELETE : 리소스 삭제

기타(참고만?)
- HEAD : GET과 동일하지만 HTTP메시지 에서 메시지(body?) 부분을 제외하고, 상태 줄과 헤더만 반환
- OPTIONS : 대상 리소스에 대한 통신 가능 옵션(메서드)을 설명(주로 CORS에서 사용)
- CONNECT : 대상 자원으로 식별되는 서버에 대한 터널을 설정
- TRACE : 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트를 수행

### HTTP 메서드 속성

- 안전(Safe Methods) : 호출해도 리소스를 변경하지 않음 (GET O, POST X)
- 멱등(Idempotent Methods) : 한 번 호출하든 두 번 호출하든 100번 호출하든 결과가 똑같다
    - GET : 한번 조회 하든, 두번 조회한든 같은 결과 조회 => 멱등
    - PUT : 결과를 대체, 따라서 같은 요청을 여러번해도 덮어버리기 때문에 최종결과는 같음 => 멱등
    - DELETE : 결과를 삭제, 같은 요청을 여러번해도 삭제된 결과는 같음 => 멱등
    - POST : 두번 호출하면 같은 결제가 중복해서 발생할 수 있기 때문 => 멱등아님
    - 활용?? :
        - 자동 복구 메커니즘(똑같은 요청을 두번해도 됨?)
        - 서버가 TIMEOUT등으로 정상 응답을 못 주었을 때, 클라이언트가 같은 요청을 다시 해도 되는가? 판단 근거
    - 멱등은 외부요인으로 중간에 리소스가 변경되는 것까지는 고려하지 않음
- 캐시 가능(Cacheable Methods)
    - 응답 결과 리소스를 캐시해서 사용해도 되는가?
    - GET,HEAD,POST,PATCH 캐시가능
    - 실제로도 GET,HEAD정도만 캐시로 사용
        - POST, PATCH는 본문 내용까지 캐시 키로 고려해야 하는데, 구현이 쉽지 않음

### HTTP 메서드 활용

#### 클라이언트에서 서버로 데이터전송
> 데이터 전달 방식
1. 쿼리 파라미터를 통한 데이터 전송 
    - GET
    - 주로 정렬 필터(검색어, 정렬 조건)
2. HTTP 메시지 바디를 통한 데이터 전송
    - POST, PUT, PATCH
    - 회원가입, 상품주문, 리소스 등록, 리소스 변경

>클라이언트에서 서버로 데이터전송 상황
1. 정적 데이터 조회(쿼리 파라미터 미사용) : 이미지, 정적 텍스트 문서, 조회이므로 GET
2. 동적 데이터 조회(쿼리 파라미터 사용) : 주로 검색, 게시판 목록에서 정렬 필터(검색어), 조회이므로 GET
3. HTML Form을 통한 데이터 전송 : 회원가입, 상품주문, 데이터변경  
=> 웹브라우저가 Form 데이터를 읽어서 HTTP메세지를 생성함  
=> body부분에 query parameter형태로 만들어져 있음  
=> method를 GET으로 바꾸면 URL경로에 query parameter로 만들어서 보냄  
=> file을 전송할 경우 enctype='multipart/form-data'로 보냄  
=> multipart 여러개의 경계를 나누어서 전송함,,,??

    HTML Form 데이터 전송 정리
    - HTML Form submit시 POST 전송
        - Content-Type : applicaton/x-www-form-urlencoded 사용
            - form의 내용을 메시지 바디를 통해서 전송(key=value, 쿼리 파라미터 형식)
            - 전송데이터를 url encoding 처리
    - HTML Form은 GET 전송도 가능
    - File 전송 : multipart/form-data
        - 파일 업로드 같은 바이너리 데이터 전송 시 사용
        - 다른 종류의 여러 파일과 폼의내용 함께 전송 가능(그래서 이름이 multipart)
    - HTML Form 전송은 GET,POST만 지원
4. HTTP API를 통한 데이터 전송
    - 회원가입, 상품주문, 데이터 변경
    - 서버 to 서버(백엔드 시스템 통신)
    - 앱 클라이언트(아이폰,안드로이드)
    - 웹 클라이언트
        - HTML에서 Form전송 대시 자바 스크립트롤 통한 통신에 사용(Ajax)
        - EX, React,Vue.js 같은 웹클라이언트와 API 통신
    - POST, PUT, PATCH : 메세지 바디를 통해 데이터 전송
    - GET : 조회, 쿼리 파라미터로 데이터 전달
    - Content-Type:application/json을 주로 사용(사실 상 표준)
        - TEXT, XML, JSON 등등 (요즘에는 JSON이 많이 사용 : 가독성이 좋고, 데이터 용량도 적기 때문)
    
    [ HTTP API 설계예시 ]
    - HTTP API - 컬렉션 
        - POST 기반 등록
        - EX, 회원관리 API 제공
            > 회원 관리 시스템  
            API 설계  - POST 기반 등록 (members : 컬렉션)

            - 회원 목록 /members -> GET
            - 회원 등록 /members -> POST
                - POST - 신규자원 등록 특징
                    - 클라이언트는 등록될 리소스의 URI를 모름 (서버가 관리함)
                    - 서버가 새로 등록된 리소스 URI를 생성  
                        => 등록시 /members로 보내고, 그 뒤의 계층 구조 리소스(등록될 리소스)는 모르고 서버가 결정함
                    - 컬렉션(Collection) 
                        - 서버가 관리하는 리소스 디렉토리
                        - 서버가 리소스의 URI를 생성하고 관리
                        - 여기서 컬렉션은 /members
            - 회원 조회 /members/{id} -> GET
            - 회원 수정 /members/{id} -> PATCH,PUT,POST
            - 회원 삭제 /members/{id} -> DELETE 
        
    - HTTP API - 스토어 : 
        - PUT 기반 등록
        - EX, 정적 컨텐츠 관리, 원격 파일 관리
            > 파일 관리 시스템
            API 설계 - PUT 기반 등록

            - 파일 목록 /files -> GET
            - 파일 조회 /files/{filename} -> GET
            - 파일 등록 /files/{filename} -> PUT (있으면 대체하고, 없으면 생성하기 때문에 이 경우에 딱 맞음)
                - PUT - 신규 자원 등록 특징
                    - 클라이언트가 리소스 URI를 알고 있어야 한다.
                        - 파일 등록 /files/{filename} -> PUT
                        - PUT /files/star.jpg (클라이언트가 해당 리소스 URI를 알고 있음)
                        - 등록 시 /files/filename로 보내고, 등록될 리소스를 client가 알고 있음 
                    - 클라이언트가 직접 리소스의 URI를 지정
                    - 스토어(Store)
                        - 클라이언트가 관리하는 리소스 저장소
                        - 클라이언트가 리소스의 URI를 알고 관리
                        - 여기서 스토어는 /files
            - 파일 삭제 /files/{filename} -> DELETE
            - 파일 대량 등록 /files -> POST

    - HTML FORM 사용 
        - 웹 페이지 회원관리
        - GET, POST만 지원하므로 제약이 있음
        - AJAX같은 기술을 사용해서 해결 가능하기는 함
        - HTTP API로 처리 못할 경우, 컨트롤 URI로 대체제로 해결
            - GET,POST만 지원하니 제역이 있음
            - 이런 제약을 해결하ㅣㄱ 위해 동사로 된 리소스 경로 사용
            - POST의 /new,/edit,/delete가 컨트롤 URI
            - HTTP 메서드로 해결하기 애매한 경우 사용(HTTP API 포함)

> 정리 : 참고하기 좋은 URI 설계 개념
- 문서(document)
    - 단일 개념(파일 하나, 객체 인스턴스, 데이터베이스 row)
    - /member/100, /files/star.jpg
- 컬렉션(collection)(대부분 컬렉션 스타일을 사용함)
    - 서버가 관리하는 리소스 디렉터리
    - 서버가 리소스의 URI를 생성하고 관리
    - /members
- 스토어(store)
    - 클라이언트가 관리하는 자원 저장소
    - 클라이언트가 리소스의 URI를 알고 관리
    - /files
- 컨트롤러(controller), 컨트롤 URI
    - 문서, 컬렉션, 스토어로 해결하기 어려운 추가 프로세스 실행
    - 동사로 직접 사용
    - /members/{id}/delete

## HTTP 상태코드
클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능
- 1xx (Informational) : 요청이 수신되어 처리 중
- 2xx (Successful) : 요청 정상 처리
    - 200 : 요청성공
    - 201 : 요청 성공해서 새로운 리소스가 생성됨 
    - 202 : 요청이 접수되었으나 처리가 완료되지 않음
    - 204 : 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없음 / 요청을 준 후 응답이 필요 없을 경우
- 3xx (Redirection) : 요청을 완료하려면, client의 추가 행동이 필요  
=> 웹 브라우저는 3xx응답의 결과에 Location 헤더가 있으면, Location 위치로 자동 이동(리다이렉트)
    - 자동 리다이렉트 흐름 :  
        1. client 요청
        2. Server 응답 : 301 Moved Permanently / Location : 변경된 위치 
        3. 자동 리다이렉트 (URL값이 변경된 위치로 리다이렉트 됨)
        4. 다시 client 리다이렉트된 경로로 요청
        5. 200 OK 응답
    - 리다이렉션 종류
        - 영구 리다이렉션 : 특정 리소스의 URI가 영구적으로 이동
            - 리소스의 URI가 영구적으로 이동
            - 원래의 URI를 사용X, 검색 엔진 등에서도 변경 인지
            - 301 Moved Permanently : 리다이렉트시 요청 메서드가 GET으로 변하고, 본문이 제거될 수 있음(MAY)
            - 308 Permanent Redirect
                - 301과 기능은 같음
                - 리다이렉트시 요청 메서드와 본문유지(처음 POST를 보내면 리다이렉트로 똑같이 POST로 요청함)
        - 일시 리다이렉션 : 일시적인 변경
            - 주문 완료 후 주문 내역 화면으로 이동
            - PRG : POST/Redirect/GET
            - 리소스의 URI가 일시적으로 변경 따라서 검색 엔진 등에서 URL을 변경하면 안됨
            - 302 Found : 리다이렉트시 요청 메서드가 GET으로 변할수 있고, 본문이 제거될 수 있음(MAY)
            - 307 Temporary Redirect
                - 302와 기능은 같음
                - 리다이렉트시 요청 메서드와 본문유지(요청 메서드를 변경하면 안됨.MUST NOT)
            - 303 See Other
                - 302와 기능은 같음
                - 리다이렉트시 요청 메서드가 GET으로 변경되어야 함
            - POST로 요청 후,  새로고침을 하게 되면 중복 요청이 됨  
            => 해결 방안 (RPG) : POST로 주문 후에 새로고침으로 인한 중복 주문 방지
                - POST로 주문 후에 주문 결과 화면을 GET 메서드로 리다이렉트
                - 새로고침해도 결과화면을 GET으로 조회
                - 중복 주문 대신에 결과 화면만 GET으로 다시 요청 
                - 순서 :
                    1. 주문 요청
                    2. 주문 응답
                    3. 주문완료 페이지로 자동 리다이렉트
                    4. 새로고침을 하여도, 중복 주문 대신 결과화면만 GET방식으로 응답 요청
                    5. 결과 화면 응답
                - URL이 이미 POST -> GET으로 리다이렉트 됨
                - 새로고침해도 GET으로 결과화면만 조회해서 에러를 방지함
        - 특수 리다이렉션 : 특수 리다이렉션 
            - 결과 대신 캐시 사용
            - 캐시를 목적으로 사용
            - 클라이언트에게 리소스가 수정되지 않았음을 알려줌. 따라서 클라이언트는 로컬 PC에 저장된 캐시를 재사용(캐시로 리다이렉트함)
            = 304응답은 응답에 메시지 바디를 포함하면 안된다(로컬캐시를 사용해야하므로)
            - 조건부 GET,HEAD 요청 시 사용
- 4xx (Client Error) : 클라이언트 오류, 잘못된 문법등으로 서버가 요청을 수행할 수 없음
    - 오류의 원인이 client에 있음(프론트)
    - 클라이언트가 이미 잘못된 요청을하였기때문에, 똑같은 재시도가 실패함  
    밤면 5xx는 서버가 요청을 처리하지 못하였기때문에, 똑같은 재시도시에 성공할 수 있음
    - 백엔드는 4xx오류를 서버 들어오기 전에 막아서, 5xx오류로 만들면 안됨
    - 401 Unauthorized : 클라이언트가 해당 리소스에 대한 인증이 필요
        - 인증 되지 않음
        - 401 오류 발생 시 응답에 WWW-Authenticate 헤더와 함꼐 인증 방법을 설명(로그인이 안됨)
        - 403 Forbidden : 서버가 요청을 이해했지만 승인을 거부함
            - 주로 인증 자격 증명은 있지만, 접근권한(인가?)이 불충분한 경우
        - 404 Not Found :
            - 요청 리소스가 서버에 없음
            - 클라이언트가 권한이 부족한 리소스에 접근할 때 해당 리소스를 숨기고 싶을때
- 5xx (Server Error) : 서버 오류, 서버가 정상 요청을 처리하지 못함
    - 서버에 문제가 있기 때문에 재시도 하면 성공할 수도 있음
    - 왠만해서는 5xx대 에러를 발생시키면 안됨(진짜 서버에 문제가 생겼을 때만 나와야함)
    - 500 Internal Server Error : 서버 문제로 오류 발생
    - 503 Service Unavailable : 서비스 이용불가

## HTTP 헤더
header - field = field-name ":" OWS field-value OWS
> 용도
- HTTP 전송에 필요한 모든 부가 정보
- ex, 메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트, 서버 정보, 캐시 관리 정보
- 표준헤더가 너무 많음
- 필요시 임의의 헤더 추가 가능

> HTTP BODY

message body
- 메시지 본문(message body)을 통해 표현 데이터 전달
- 메시지 본문 = 페이로드(payload)
- 표현은 요청이나 응답에서 전달할 실제 데이터
- 표현 헤더는 표현 데이터를 해석할 수 있는 정보 제공
    - 데이터 유형(html,json), 데이터 길이, 압축 정보 등등

### 표현
- Content-Type : 표현 데이터의 형식
    - 미디어 타입, 문자 인코딩
- Content-Encoding : 표현 데이터의 압축 방식 /인코딩
    - 표현 데이터를 압축하기 위해 사용
    - 데이터를 전달하는 곳에서 압축 후 인코딩 헤더 추가
    - 데이터를 읽는 쪽에서 인코딩 헤더의 정보로 압축 해제
- Content-Language : 표현 데이터의 자연언어
    - 표현뎅터의 자연 언어를 표현
- Content-Length : 표현 데이터의 길이
    - 바이트 단위
    - Transfer-Encoding(전송코딩)을 사용하면, Content-Length를 사용하면 안됨

- 표현 헤더는 전송, 응답 둘다 사용

### 협상(콘텐츠 네고시에이션)
클라이언트가 선호하는 표현 요청(표현헤더, 표현 데이터)
- Accept : 클라이언트가 선호하는 미디어 타입 전달
- Accept-Charset : 클라이언트가 선호하는 문자 인코딩
- Accept-Encoding : 클라이언트가 선호하는 압축 인코딩
- Accept-Language : 클라이언트가 선호하는 자연언어
    - 클라이언트가 ko를 선호한다고 하고, 서버에 해당 언어를 지원하면, ko로 답변해줌
    - 클라이언트가 ko를 선호한다고 하고, 서버에 해당 언어를 지원하지 않으면, 기본언어를 보내줌(우선순위 발생)

- 협상 헤더는 요청시에만 사용

> 협상과 우선순위1 : Quality Values(q)
- Quality Values(q)값 사용
- 0~1, 클수록 높은 우선순위
- 생략하면 1
- Accept-Language : ko-KR;1=0.9,en-US;q=0.8,en;q=0.7
    1. ko-KR;q=1(q 생략)
    2. ko; q=0.9
    3. en-US;q=0.8
    4. en;q=0.7

> 협상과 우선순위2 : Quality Values(q)
- 구체적인 것이 우선
- Accept : text/*, text/plain, text/plain;format=flowed, */*
    1. text/plain;format=flowed
    2. text/plain
    3. text/*
    4. */*

> 협상과 우선순위3 : Quality Values(q)
- 구체적인 것을 기준으로 미디어 타입을 맞춤..??
- Accept : text/*;q=0.3, text/html;q=0.7, text/html;level=1,text/html;level=2;q=0.4,*/*;q=0.5 


### 전송방식
- 단순전송(Content-Length) : Content-Length 길이를 알 경우 명시해서 요청
- 압축전송(Content-Encoding) : 말그대로 압축해서 Content-Length 길이를 줄여서 전송, 대신 Content-Encoding방벙을 알고 있어야함
- 분할전송(Transfer-Encoding) : Transfer-Encoding : chunked 하면 분할해서 전송시킴  
    => 용량이 너무커서 분할해서 전송  
    => 분할해서 전송하기 때문에 Content-Length을 넣으면 안됨 분할해서 보내기때문에 처음이 예상이 안되므로 작성하지 않음
- 범위전송(Range,Content-Range) : 부분만 받았을경우 처음부터 다시 받지않고 범위만 받아서 전송함 Content-Range를 정해서 보냄

### 일반정보
- From : 유저 에이전트의 이메일 정보
    - 일반적으로 잘 사용되지않음
    - 검색 엔진 같은 곳에서 주로 사용(출처문제?)
    - 요청에서 사용
- Referer : 이전 웹페이지 주소
    - 현재 요청된 페이지의 이전 웹사이트 주소
    - A -> B로 이동하는 경우 B를 요청할때 Referer : A를 포함해서 요청
    - Referer를 사용해서 유입경로 분석 가능
    - 요청에서 사용
- User-Agent : 유저 에이전트 애플리케이션 정보
    - 클라이언트의 애플리케이션 정보(웹 브라우저 정보, 등등)
    - 통계정보
    - 어떤 종류의 브라우저에서 장애가 발생하는지 파악 가능
    - 요청에서 사용
- Server : 요청을 처리하는 오리진(ORIGIN) 서버의 소프트웨어 정보
    - 응답에서 사용
- Date : 메시지가 생성된 날짜
    - 응답에서 사용

### 특별한 정보
- HOST : 요청한 호스트 정보(도메인)
    - 필수!! 중요!!
    - 요청에서 사용
    - 하나의 서버가 여러 도메인을 처리해아 할 때 구분해줌
    - 하나의 IP 주소에 여러 도메인이 적용되어 있을 때 구분해줌
- Location : 페이지 리다이렉션
    - 웹 브라우저는 3xx 응답의 결과에 Location 헤더가 있으면, Location위치로 자동 이동(리다이렉트)
    - 응답코드 3xx에서 설명
    - 201(Created) : Location값은 요청에 의해 생성된 리소스 URI
    - 3xx(Redirection) : Location 값은 요청을 자동으로 리디렉션하기 위한 대상 리소스를 가리킴
- Allow : 허용 가능한 HTTP 메서드 
    - 경로는 있는데 HTTP 메서드가 다를 경우?에 사용됨
    - 405(Method Not Allowd)에서 응답에 포함해야함
    - Allow : GET, HEAD, PUT
- Retry-After : 유저 에이전트가 다음 요청을 하기까지 기다려야 하는 시간
    - 503(Service Unavailable) : 서비스가 언제까지 불능인지 알려줄 수 있음
    
        [표기방법]
    
    - Retry-After:Fri,31 Dec 1999 23:59:59 GMT (날짜 표기)
    - Retry-After:120(초단위 표기)


### 인증
- Authorization : 클라이언트 인증 정보를 서버에 전달
- WWW-Authenticate : 리소스 접근시 필요한 인증 방법 정의
    - 접근을 했는데 인증이 제대로 이루어지지 않은 경우  
    => 401 Unauthorized 응답과 함께 사용됨

### 쿠키
- Set-Cookie : 서버에서 클라이언트로 쿠키 전달(응답)
- Cookie : 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청시 서버로 전달

> if 쿠키 미사용

1. 로그인 요청
2. 로그인 응답
3. 로그인 이후 다시 페이지에 접근
4. 로그인 정보를 모르니 client를 구분할 수 없으므로 그냥 응답

=> 이유 : HTTP가 무상태(Stateless)프로토콜이기 때문에, 응답을 주고 받으면 연결이 끊어지고, 이전 요청은 기억하지 못해서 그냥 응답  
=> 이를 해결하기 위해서는 모든 요청과 링크에 사용자 정보를 포함해야함  
=> 보안문제가 발생하고, 브라우저를 완전 종료하고 다시 열었을 경우 안됨(요즘에는 web storeage?가 있어서 괜찮을 수 있음)

> 이를 해결하기 위해 쿠키 사용

1. 로그인
2. 로그인 응답 + Set-Cookie에 정보 저장 => 웹브라우저 내부의 쿠키 저장소에 저장됨
3. 로그인 이후 다시 페이지에 접근할때 자동으로 쿠키 저장소를 뒤져서 정보를 가지고 요청을 보냄
4. client가 사용자 정보를 보냈기 때문에 사용자 정보에 응답함

> 사용처 
- 사용자 로그인 세션관리  
=> 쿠키에 로그인 정보를 바로 저장하면 위험하기 때문에, session key값을 cookie에 저장시킴
- 광고 정보 트래킹
> 쿠키 정보는 항상 서버에 전송됨
- 네트워크 트래픽 추가 유발
- 최소한의 정보만 사용(세션 id, 인증토큰)
- 서버에 전송하지 않고, 웹 브라우저 내부에 데이터를 저장하고 싶으면 웹스토리지(localStorage, sessionStorage) 참고
> 주의!
- 보안에 민감한 데이터는 저장하면 안됨(주민번호, 신용카드 번호 등등)

> 쿠키 - 생명주기
- Set-Cookie:expires=?? -> 만로일이 되면 쿠키 삭제
- Set-Cookie:max-age -> 0이나 음수를 지정하면 쿠키 삭제
- 세션 쿠키:만료 날짜를 생략하면 브라우저 종료시 까지만 유지
- 영속 쿠키:만료 날짜를 입력하면 해당 날짜까지 유지

> 쿠키 - 도메인
- 명시할 경우 : 명시한 문서 기준 도메인 + 서브 도메인 포함
    - domain=example.org를 지정해서 쿠키 생성 : example.org는 물론이고, dev.example.org도 쿠키 접근(하위 도메인?에서도 접근?)
- 생략할 경우 : 현재 문서 기준 도메인만 적용
    - example.org에서 쿠키를 생성하고 domain지정을 생략 : example.org에서만 쿠키 접근, dev.example.org는 쿠키 미접근(하위 도메인?에서 미접근)

> 쿠키 - 경로
- 이 경로를 포함한 하위 경로 페이지만 쿠키 접근
- 일반적으로 path=/ 루트로 지정(모든 경로에 쿠키 접근 허용)
- ex, 
    - path = /home 가능
    - /home 가능
    - /home/level1 가능
    - /home/level1/level2 가능
    - /hello 불가능 (레벨이 안맞을 경우?만 안됨)

> 쿠키 - 보안
- Secure 
    - 쿠키는 HTTP,HTTPS를 구분하지 않고 전송
    - Secure를 적용하면, HTTPS인 경우에만 전송
- HttpOnly
    - XSS 공격 방지
    - 자바스크립트에서 접근 불가(document.cookie)
    - HTTP 전송에만 사용
- SameSite
    - XSRF 공격 방지
    - 요청 도메인과 쿠키에 설정된 도메인이 같은 경우에만 쿠키 전송

### 캐시

[캐시 요청 시]
> 캐시가 없을 경우
- 데이터가 변경되지 않아도 계속 네트워크를 통해서 데이터를 다운로드 받아야한다.
- 인터넷 네트워크는 매우 느리고, 비싸다
- 브라우저 로딩속도가 느리다
- 느린 사용자 경험

> 캐시가 있을 경우
- 캐시 덕분에 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다.
- 비싼 네트워크 사용량을 줄일 수 있다.
- 브라우저 로딩속도가 매우 빠르다
- 빠른 사용자 경험

> 캐시 시간 초과
- 캐시 유효 시간이 초과되면, 서버를 통해 데이터를 다시 조회하고, 캐시를 갱신한다
- 이때 다시 네트워크 다운로드가 발생(헤더 0.1M, 바디 1.0M)

=> 만약, 클라이언트와 서버의 데이터가 일치한다면, 굳이 전체를 다시 다운로드 받아야 할 필요가 있는가?  
=> 조건부 요청이 필요함

### 캐시 : 검증헤더와 조건부 요청
[ 캐시 시간이 초과될 경우 ]
- 캐시 만료후에도 서버에서 데이터를 변경하지 않았을 경우
- 생각해보면 데이터를 전송하는 대신에 저장해 두었던 캐시를 재사용 할 수 있음(시간이 초과해도?)
- 단, 클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법 필요 => 검증헤더가 필요함

> ## 검증 헤더 + 조건부 요청

[ 과정 ]
- 헤더에 최종수정 날짜를 추가 (Last-Modified) = 검증헤더
- 응답결과를 캐시 저장소에 저장할때, 헤더에 추가한 최종 수정날짜도 같이 추가함
- 캐시 시간이 초과 될경우, 조건부 요청(if-modified-since)와 최종 수정일과 같다면, 데이터가 아직 수정되지 않았음으로 클라이언트의 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있음
- 서버에서 수정이 안되었음을 확인하면, 304 Not Modified을 응답으로 보냄(HTTP Body가 없음)  
=> body가 없고, 헤더만보내기때문에, 데이터 용량을 줄일 수 있음(헤더 0.1M)(네트워크 부하가 둘어둠)
- 304를 보냈기때문에 응답결과를 재사용, 헤더 데이터 갱신(캐시 시간이 리셋됨, 다시 사용할 수 있게됨)
- 캐시를 조회해서 재사용함

[ 정리 ]
- 캐시 유효 시간이 초과해도, 서버의 데이터가 갱신되지 않으면, 304 Not Modified+헤더 메타 정보만 응답(바디x)
- 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신
- 클라이언트는 캐시에 저장되어 있는 데이터 재활용
- 결과적으로 네트워크 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드

=> 매우 실용적인 해결책

> 검증 헤더
- 캐시 데이터와 서버 데이터가 같은지 검증하ㅡㄴ 데이터
- Last-Modified, ETag
> 조건부 요청 헤더
- 검증 헤더로 조건에 따른 분기룰 서버에 요청
- If-Modified-Since(~이후로 수정이 되었는가?)
    - If-Modified-Since / If-Unmodified-Since : Last-Modified 사용
    - 데이터 미 변경 시
        - 304 Not Modified, 헤더 데이터만 전송(BODY 미포함)
            - 304 Not Modified 리다이렉션 : 캐시로 리다이렉션
        - 전송 용량 0.1M(헤더 0.1M, 바디 1.0M)
    - 데이터 변경 시
        - 200 OK, 모든 데이터 전송(BODY 포함)
        - 전송 용량 1.1M(헤더 0.1M, 바디 1.0M)
    - 단점 : 
        - 1초 미만 단위로 캐시 조정 불가능
        - 날짜 기반의 정해진 로직 사용
        - 데이터를 수정해서 날짜가 다르지만, 같은 데이터를 수정해서 데이터 결과가 똑같은 경우(날짜는 갱신되었지만, 데이터는 갱신되지 않은경우(EX,같은데이터로 복붙))
        - 서버에서 별도의 캐시 로직을 관리하고 싶은 경우  
        EX, 스페이스나 주석처럼 크게 영향이 없는 변경에서 캐시를 유지하고 싶은 경우
- If-None-Match
    - If-Match, If-None-Match : ETag(Entity Tag) 사용
    - 캐시용 데이터에 날짜가 아니라 임의의 고유한 버전 이름을 달아둠
    - 데이터가 변경되면 이 이름을 바꾸어서 변경함(Hash를 다시 생성)  
    => hash에 같은파일을 넣으면 같은 hash값이 나오지만, 다른 파일을 넣으면, 다른 hash값이 나옴  
    => 이렇게 변경되어도 같은 데이터면 같은 hash값이 나와서 이름이 수정되지 않지만, 다른 데이터로 변경해서 넣으면 다른 hash값이 나와서 이름이 수정됨
    - 진짜 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 받기
    - 과정
        1. 요청 / 응답 (1.1M) => 응답 헤더에 ETag가 추가되어서 돌아옴
        2. 캐시저장소 에 ETag가 저장됨
        3. 이후 시간이 초과되면, 요청시에 헤더에 If-None-Match에 ETag값을 추가해서 요청 보냄
        4. 만약 match가 되면 304 Not Modified / 안되면 수정되었으므로 200 OK 보냄
    - 정리
        - 진짜 단순하게 ETag만 서버에 보내서 같으면 유지, 다르면 다시 받기
        - 캐시 제어 로직을 서버에서 완전히 관리
        - 클라이언트는 단순히 이 값을 서버에 제공(클라이언트는 캐시 메커니즘을 모름)
        - ex
            - 서버는 배타 오픈 기간인 3일 동안 파일이 변경되어도 ETag를 동일하게 유지
            - 애플리케이션 배포 주기에 맞추어 ETag 모두 갱신
- 조건이 만족하면 200 OK
- 조건이 만족하지 않으면 304 Not Modified

### 캐시와 조건부 요청 헤더
> 캐시 제어 헤더
- Cache-Control : 캐시 제어 (요즘에는 하위호환없이 혼자서 다 제어할 수 있음)
    - Max-age : 캐시 유효 시간, 초 단위
    - no-cache : 데이터는 캐시해도 되지만, 캐시서버가 아니라? 항상 원(origin) 서버에 검증하고 사용
    - no-store : 데이터에 민감한 정보가 있으므로 저장하면 안됨(메모리에서 사용하고 최대한 빨리 삭제)
- Pragma : 캐시 제어(하위 호환) = no-cache 하위호환
- Expires : 캐시 유효 기간(하위 호환) = Max-age 하위호환
    - 캐시 만료일을 정확한 날짜로 지정 <-> Max-age는 초단위로 지정하기 때문에 더 유연함

### 프록시 캐시
: 원(origin)서버에 물리적으로 거리가 먼 client의 요청이 너무 많아서 속도가 느려질 경우, 대신 그 요청을 받아서 나중에 한꺼번에 원서버에 요청을 보내는 서버(물리적으로 client와 가가운 위치에 있음) <= public 캐시 (local 저장되는 캐시를 private 캐시라고 함)

> Cache-Control 캐시지시어 - 기타
- public : 응답이 public캐시에 저장되어도 됨 
- private : 응답이 해당 사용자만을 위한 것임. private 캐시에 저장해야함(기본값). 프록시 캐시에 저장되면 안됨
- s-maxage : 프록시 캐시에만 적용되는 max-age
- Age : 60(HTTP 헤더) : 오리진 서버에서 응답 후 프록시 캐시내에 머문 시간(초)

> ## 원(origin)서버 : 원래 진짜 자원과 리소스가 있는 서버

### 캐시 뮤효화
> Cache-Control : 확실한 캐시 무효화 응답  
=> 캐시를 적용하지 않아도, 웹브라우저가 임의로 캐시를 적용함  

캐시 지시어(directives) - 확실한 캐시 무효화  
=> 무효화를 위해서 아래 헤더를 모두 넣어줌  
Cache-Control : no-cache, no-store, must-revalidate  
Pragma : no-cache (HTTP 1.0 하위 호환)
- Cache-Control   
    - no-cache : 데이터는 캐시해도 되지만, 항상 원 서버에 검증하고 사용
        - 기본동작
        1. 웹 브라우저가 캐시 서버 요청 (no-cache + ETag)
        2. 프록시 캐시가 no-cache이므로 원서버로 요청 (no-cache + ETag)
            - 만약에 여기서 순간적으로 네트워크 단절이 일어나 원서버 접근불가라면?  
            => Error 혹은 200 OK로 웹브라우저에 응답할수 있음  
            => 오류보다는 오래된 데이터를 보여 주도록 세팅이 되어있으면 200 OK를 보냄
        3. 원서버 검증
        4. 프록시 캐시에게 304 응답
        5. 웹브라우저로 304응답
        6. 캐시 저장소에서 캐시 데이터 사용
    - no-store : 데이터에 민감한 정보가 있으므로 저장하면 안됨(메모리에서 사용하고 최대한 빨리 삭제)
    - must-revalidate
        - 캐시 만료후 최초 조회 시 원 서버에 검증해야함
        - 원 서버 접근 실패시 반드시 오류가 발생해야함 - 504(Gateway Timeout)
        - must-revalidate는 캐시 유효 시간이라면 캐시를 사용함
        - 기본동작
        1. 웹 브라우저가 캐시 서버 요청 (must-revalidate + ETag)
        2. 프록시 캐시가 must-revalidate이므로 원서버로 요청 (must-revalidate + ETag)
            - 만약에 여기서 순간적으로 네트워크 단절이 일어나 원서버 접근불가라면?  
            => 504 Gateway Timeout을 웹브라우저에 응답함 (no-cache와는 달리 항상 오류를 반환)  
            => 오래된 정보도 보이고 싶지 않을 경우 사용(보안문제)
        3. 원서버 검증
        4. 프록시 캐시에게 304 응답
        5. 웹브라우저로 304응답
        6. 캐시 저장소에서 캐시 데이터 사용
- Pragma : no-cache (HTTP 1.0 하위 호환 <= 과거 웹브라우저 때문)






